<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>markdown语法</title>
    <url>/2023/11/91fba8963d27.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="使用的工具："><a href="#使用的工具：" class="headerlink" title="使用的工具："></a>使用的工具：</h2><p><a href="https://typoraio.cn/">typora官网</a></p>
<p><a href="https://support.typoraio.cn/zh/Markdown-Reference/">typora官方学习markdown手册</a></p>
<p><a href="https://www.cnblogs.com/KoiC/p/17073950.html">仅供学习参考使用的免费typora</a></p>
<h2 id="常用typora快捷键："><a href="#常用typora快捷键：" class="headerlink" title="常用typora快捷键："></a>常用typora快捷键：</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CTRL+K</td>
<td>插入超链接</td>
</tr>
<tr>
<td>CTRL+T</td>
<td>插入表格</td>
</tr>
<tr>
<td>CTRL+Enter</td>
<td>表格里下方插入一行</td>
</tr>
<tr>
<td>CTRL+B</td>
<td>字体加粗</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>CTRL+Shift+[</td>
<td>有序列表</td>
</tr>
<tr>
<td>CTRL+Shift+]</td>
<td>无序列表</td>
</tr>
<tr>
<td>CTRL+Shift+K</td>
<td>代码块</td>
</tr>
<tr>
<td>CTRL+Shift+M</td>
<td>公式块（理解为：math）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="后续进行补充"><a href="#后续进行补充" class="headerlink" title="后续进行补充"></a>后续进行补充</h2><p>暂时完结</p>
]]></content>
      <categories>
        <category>工具相关</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度消失、梯度爆炸怎么解决</title>
    <url>/2023/11/20b3b53ad2ba.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><blockquote>
<p>梯度消失与梯度爆炸其实是一种情况，看参考链接的文章就知道了。</p>
</blockquote>
<p>两种情况下梯度消失经常出现，一是在<strong>深层网络</strong>中，二是采用了<strong>不合适的损失函数</strong>，比如sigmoid。梯度爆炸一般出现在深层网络和权值初始化值太大的情况下。</p>
<h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><ol>
<li><p>预训练加微调。</p>
<p>此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。此方法来自Hinton在2006年发表的一篇论文，Hinton为了解决梯度的问题，提出采取无监督逐层训练方法，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。</p>
</li>
<li><p>梯度剪切、权重正则（针对梯度爆炸）。</p>
<p><strong>梯度剪切</strong>这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</p>
<p><strong>权重正则化</strong>（weithts regularization）比较常见的是l1正则，和l2正则，在各个深度框架中都有相应的API可以使用正则化。</p>
</li>
<li><p>使用不同的激活函数。</p>
<p>relu、leakrelu、elu等激活函数。</p>
</li>
<li><p>使用batchnorm。</p>
<p>Batchnorm本质上是解决反向传播过程中的梯度问题。batchnorm全名是batch normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。</p>
</li>
<li><p>使用残差结构。</p>
<p>事实上，就是残差网络的出现导致了image net比赛的终结，自从残差提出后，几乎所有的深度网络都离不开残差的身影，相比较之前的几层，几十层的深度网络，在残差网络面前都不值一提，残差可以很轻松的构建几百层，一千多层的网络而不用担心梯度消失过快的问题，原因就在于残差的捷径（shortcut）部分</p>
</li>
<li><p>使用LSTM网络。</p>
<p>LSTM全称是<strong>长短期记忆网络</strong>（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)。LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“，因此，经常用于生成文本中。目前也有基于CNN的LSTM，之后可以尝试一下。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://zhuanlan.zhihu.com/p/622605118?utm_id=0">https://zhuanlan.zhihu.com/p/622605118?utm_id=0</a>	“参考链接1”</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>过拟合和欠拟合怎么解决</title>
    <url>/2023/11/c1a54a404412.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><blockquote>
<p>过拟合和欠拟合是机器学习中常见的问题。</p>
</blockquote>
<ul>
<li><strong>过拟合</strong>指的是模型过于复杂，在训练数据上表现良好，但是在新数据上表现却很差。</li>
<li><strong>欠拟合</strong>指的是模型在训练集、验证集和测试集上均表现不佳的情况。</li>
</ul>
<h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><blockquote>
<p>过拟合和欠拟合的解决办法较为相对，反面基本可以解决另一个问题。下面谈谈针对过拟合。</p>
</blockquote>
<ol>
<li><p>增加数据量。</p>
<p>当数据量较少时，模型容易过拟合。因此，增加数据量是解决过拟合问题的重要方法之一。如果数据集无法扩充，可以通过数据增强的方式来达到类似的效果。</p>
</li>
<li><p>简化模型结构。</p>
<p>过于复杂的模型容易导致过拟合。因此，可以通过简化模型结构的方式来解决过拟合问题。例如，减少深度学习模型的层数、减少神经元数量等。此外，也可以通过增加正则化项来限制模型的复杂度。</p>
</li>
<li><p>采用正则化方法。</p>
<p>正则化是一种常用的防止过拟合的方法。它通过在损失函数中加入正则化项，对模型参数进行惩罚，从而限制模型的复杂度。常见的正则化方法包括L1正则化、L2正则化等。</p>
</li>
<li><p>采用Dropout方法。</p>
<p>Dropout是一种常用的防止过拟合的方法。它通过在训练过程中随机地将一些神经元的输出置为0，从而强制模型学习到多种特征表示。这样可以使得模型更加鲁棒，防止过拟合。</p>
</li>
<li><p>交又验证。</p>
<p>交又验证是一种常用的评估模型性能的方法。它将数据集分为若干份每次将其中一份作为验证集，其余部分作为训练集。这样可以多次训练模型，并在验证集上进行测试，从而得到一个更加准确的模型性能评估结果。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://wenku.baidu.com/view/b718aa443269a45177232f60ddccda38376be1e6.html">https://wenku.baidu.com/view/b718aa443269a45177232f60ddccda38376be1e6.html</a>	“参考链接1”<br>[2]:<a href="https://blog.csdn.net/m0_69082030/article/details/128175288">https://blog.csdn.net/m0_69082030/article/details/128175288</a>	“参考链接2”</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>有限状态自动机</title>
    <url>/2023/11/261d7fd3675f.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="定义——有限自动机"><a href="#定义——有限自动机" class="headerlink" title="定义——有限自动机"></a>定义——有限自动机</h2><blockquote>
<p>有限状态机（Finite-state machine, FSM），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。<br>有限状态机可以将复杂的逻辑简化为有限个稳定状态，在稳定状态中判断事件。其中有限不是指有限次处理，而是有限个稳定状态。</p>
</blockquote>
<p>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p>
<p>在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。</p>
<p><strong>有限状态机在日常中也随处可见:</strong></p>
<ul>
<li>红绿灯控制系统：主干道、支干道的黄灯、红灯、绿灯交替显示；</li>
<li>地铁入口的门禁闸机：只有被闸机接受的刷卡行为，闸机才会将关闭状态变为开启状态；</li>
<li>自动售卖机，只有投入合适的硬币，售卖机才会吐出相应的产品；</li>
<li>密码箱，只有输入正确的密码序列，密码箱才会变为开启状态。</li>
</ul>
<p><strong>状态机的要素</strong><br>状态机的本质是有向图：包括节点和路径。</p>
<ul>
<li>节点表示状态，路径表示状态迁移。</li>
</ul>
<p>大多状态机在路径上会增加一些附加信息来表明状态迁移的细节：条件 &#x2F; 动作。前者表示引起状态迁移的事件，后者表示与该状态迁移相关联的动作。</p>
<p>比如：地铁入口的门禁闸机，在用户刷卡后，如果接受，则闸机会打开闸门。这里的“用户刷卡”就是“条件”，“闸机会打开闸门”就是动作。</p>
<p>状态机可归纳为<strong>6个要素</strong>，即<strong>活跃状态（现态）</strong>、<strong>输入事件（条件）</strong>、<strong>输出事件（动作）</strong>、<strong>次态</strong>、<strong>初始</strong>和<strong>终止状态</strong>。“活跃状态”和“条件”是因，“动作”和“次态”是果。详解如下：</p>
<ul>
<li>活跃状态，也叫现态：是指当前所处的状态。任何时候，只有一个状态能够成为活跃状态；</li>
<li>输入事件：又称为“条件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移；</li>
<li>输出事件：又称为“动作”，条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态；</li>
<li>次态：条件满足后要迁往的新状态。“次态”是相对于“活跃状态”而言的，“次态”一旦被激活，就转变成新的“活跃状态”了；</li>
<li>初始状态：即没有状态转入的状态。只有一个初始状态</li>
<li>终止状态：即没有状态转出的状态。只有一个终止状态</li>
</ul>
<p>可以用 <strong>迁移状态表</strong> 表示整个过程，如下表：</p>
<table>
<thead>
<tr>
<th align="center">活跃状态 \ 输入&#x2F;输出</th>
<th align="center">触发条件1&#x2F;[执行动作1]</th>
<th align="center">触发条件2&#x2F;[执行动作2]</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">初始状态</td>
<td align="center">中间状态1</td>
<td align="center">中间状态2</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态1</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态2</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态…</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
</tbody></table>
<p><strong>有限状态机分类</strong><br>主要有 <strong>接收器（acceptors）</strong> 和 <strong>转换器（transducers）</strong> 两种。转换器（transducers）依据状态和输入的关系，又分为两种：<strong>moore 状态机</strong>和 <strong>mealy 状态机</strong>。</p>
<ul>
<li><p><strong>接收器（acceptors）</strong><br>接收器是指产生一个二值的输出，指示接收的输入是否能被接受。比如地铁入口的门禁闸机，在用户刷卡后决定是否打开闸门放行</p>
</li>
<li><p><strong>transducers(转换器)</strong><br>转换器（moore 状态机和 mealy 状态机）一般输出会受输入序列顺序影响，mealy 状态机还会受当前状态影响。我们一般看到的状态机大部分是 mealy 状态机。</p>
</li>
</ul>
<h2 id="力扣8-字符串转换整数-atoi-官方代码参考"><a href="#力扣8-字符串转换整数-atoi-官方代码参考" class="headerlink" title="力扣8.字符串转换整数 (atoi)官方代码参考"></a>力扣8.字符串转换整数 (atoi)官方代码参考</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span> &#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="type">long</span> <span class="type">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>)</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str)</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/651128045">编程——有限自动机 - leancode的文章 - 知乎</a><br><a href="https://leetcode.cn/problems/string-to-integer-atoi/solutions/183164/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/">leetcode8.字符串转换整数 (atoi)</a></p>
]]></content>
      <categories>
        <category>编程的额外知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础之指针</title>
    <url>/2021/06/315ec67734e1.html</url>
    <content><![CDATA[<p>[toc]</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础之格式化输出</title>
    <url>/2023/11/dcbca6ff400e.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="使用printf-函数进行格式化输出："><a href="#使用printf-函数进行格式化输出：" class="headerlink" title="使用printf()函数进行格式化输出："></a>使用printf()函数进行格式化输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> price = <span class="number">19.99</span>;</span><br><span class="line"><span class="type">int</span> quantity = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total price: $%.2f\n&quot;</span>, price * quantity);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Quantity: %04d\n&quot;</span>, quantity);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">%.2f用于格式化输出小数点后两位；%04d用于设置输出占据宽度为4，并在前面填充零。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用&lt;&lt;运算符和格式控制符进行输出："></a>使用&lt;&lt;运算符和格式控制符进行输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Pi: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">std::fixed和std::setprecision(2)用于固定小数位并设置精度为两位小数。</span></span><br><span class="line"><span class="comment">std::setw(5)和std::setfill(&#x27;0&#x27;)用于设置输出宽度为5，并在前面填充零。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="使用字符串流（stringstream）进行格式化输出："><a href="#使用字符串流（stringstream）进行格式化输出：" class="headerlink" title="使用字符串流（stringstream）进行格式化输出："></a>使用字符串流（stringstream）进行格式化输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> weight = <span class="number">65.5</span>;</span><br><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; weight &lt;&lt; <span class="string">&quot;kg\n&quot;</span>;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将要输出的内容逐个写入字符串流中，然后通过ss.str()将字符串流的内容转换为字符串进行输出。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础知识</title>
    <url>/2023/06/8ae987bd8514.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题部分"><a href="#问题部分" class="headerlink" title="问题部分"></a>问题部分</h2><h3 id="1-说说include头文件的顺序以及双引号””和尖括号的区别"><a href="#1-说说include头文件的顺序以及双引号””和尖括号的区别" class="headerlink" title="1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h3><blockquote>
<p><a href="#1">参考答案</a></p>
</blockquote>
<h3 id="2-导入C函数的关键字是什么，C-编译时和C有什么不同？"><a href="#2-导入C函数的关键字是什么，C-编译时和C有什么不同？" class="headerlink" title="2.导入C函数的关键字是什么，C++编译时和C有什么不同？"></a>2.导入C函数的关键字是什么，C++编译时和C有什么不同？</h3><blockquote>
<p><a href="#2">参考答案</a></p>
</blockquote>
<h3 id="3-C-中前置操作性能一定优于后置操作吗？"><a href="#3-C-中前置操作性能一定优于后置操作吗？" class="headerlink" title="3.C++中前置操作性能一定优于后置操作吗？"></a>3.C++中前置操作性能一定优于后置操作吗？</h3><blockquote>
<p><a href="#3">参考答案</a></p>
</blockquote>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><blockquote>
<p><a href="#4">参考答案</a></p>
</blockquote>
<h2 id="答案部分，仅供参考"><a href="#答案部分，仅供参考" class="headerlink" title="答案部分，仅供参考"></a>答案部分，仅供参考</h2><p id='1'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案1-说说include头文件的顺序以及双引号””和尖括号的区别"><a href="#答案1-说说include头文件的顺序以及双引号””和尖括号的区别" class="headerlink" title="答案1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>答案1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h3><p><strong>区别</strong>：</p>
<ul>
<li>（1）尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。</li>
<li>（2）编译器预处理阶段查找头文件的路径不一样。</li>
</ul>
<p><strong>查找路径</strong>：</p>
<ul>
<li>（1）使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量。</li>
<li>（2）使用双引号””的头文件的查找路径：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。</li>
</ul>
<p id='2'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案2-导入C函数的关键字是什么，C-编译时和C有什么不同？"><a href="#答案2-导入C函数的关键字是什么，C-编译时和C有什么不同？" class="headerlink" title="答案2.导入C函数的关键字是什么，C++编译时和C有什么不同？"></a>答案2.导入C函数的关键字是什么，C++编译时和C有什么不同？</h3><ul>
<li><strong>关键字</strong>：在C++中，导入C函数的关键字是<strong>extern</strong>，表达形式为**extern “C”**， extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</li>
<li><strong>编译区别</strong>：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时<strong>不会</strong>带上函数的<strong>参数类型</strong>，一般只包括<strong>函数名</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extern示例</span></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span><span class="comment">//string.h里边包含了要调用的C函数的声明</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span></span><br></pre></td></tr></table></figure>


<p id='3'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案3-C-中前置操作性能一定优于后置操作吗？"><a href="#答案3-C-中前置操作性能一定优于后置操作吗？" class="headerlink" title="答案3.C++中前置操作性能一定优于后置操作吗？"></a>答案3.C++中前置操作性能一定优于后置操作吗？</h3><blockquote>
<p><a href="https://m.elecfans.com/article/1929824.html">详细参考链接</a></p>
</blockquote>
<p><strong>结论</strong>：</p>
<ul>
<li>原理来说：前置操作遵循的规则是change-then-use，而后置操作遵循的规则是use-then-change。所以，前置操作就地修改对象；后置操作的时候，会使得编译器在实现该操作的时候，先把之前的值进行拷贝备份，然后对值进行更改操作，最后返回之前备份的值。因此，后置操作会产生临时变量，而前置操作不会。</li>
<li>对于内置类型，前置操作和后置操作二者在性能上无差异，这是因为编译器会对其进行优化。</li>
<li>对于自定义类型，前置操作的性能远优于后置操作。除非必须使用i++以满足编码场景，否则，在任何情况下都建议使用++i这种前置操作。</li>
<li>很多人都会认为前置操作性能优于后置操作，这是错误的观点，在此进行下纠正，准确的说法应该是前置操作不会比后置操作性能差。</li>
</ul>
<p id='4'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案4"><a href="#答案4" class="headerlink" title="答案4"></a>答案4</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++容器之填充递增序列</title>
    <url>/2023/11/2fc88ef6a3e9.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="iota函数介绍："><a href="#iota函数介绍：" class="headerlink" title="iota函数介绍："></a>iota函数介绍：</h2><blockquote>
<p>C++标准库提供了丰富的算法，其中之一就是iota算法。iota算法用于填充一个区间，以递增的方式给每个元素赋予一个值。</p>
<p>iota算法是C++标准库中的一个函数模板，用于填充一个区间。它通过指定一个起始值，并根据区间的长度递增生成后续的值。它有助于快速生成递增的序列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h2><blockquote>
<p>first 和 last 是迭代器，表示要填充的区间的起始位置和结束位置。<br>value 是起始值，该值将根据区间的长度逐步增加。<br>无返回值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iota</span><span class="params">(ForwardIt first, ForwardIt last, T value)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h2><blockquote>
<p>示例1：vector</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">iota</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1 2 3 4 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在这个示例中，我们创建了一个长度为5的整数向量nums，并使用iota算法填充了向量的元素。起始值为1，根据向量的长度递增生成后续的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例2：list</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::list&lt;<span class="type">char</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">iota</span>(chars.<span class="built_in">begin</span>(), chars.<span class="built_in">end</span>(), <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ch : chars) &#123;</span><br><span class="line">        std::cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">A B C D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在这个示例中，我们创建了一个长度为4的字符型列表chars，并使用iota算法填充了列表的元素。起始值为’A’，根据列表的长度递增生成后续的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例3：array</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">float</span>, 6&gt; values;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">iota</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), <span class="number">1.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : values) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1.5 2.5 3.5 4.5 5.5 6.5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在这个示例中，我们创建了一个大小为6的浮点型数组values，并使用iota算法填充了数组的元素。起始值为1.5，根据数组的大小递增生成后续的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://developer.aliyun.com/article/1350264">https://developer.aliyun.com/article/1350264</a>	“参考资料1”</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语法之priority_queue自定义大小根堆</title>
    <url>/2023/10/af4bec111749.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;priority_queue&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="基础调用API"><a href="#基础调用API" class="headerlink" title="基础调用API"></a>基础调用API</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; q1;<span class="comment">//默认大根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; q2;<span class="comment">//完全体的大根堆，和上述一致</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q3;<span class="comment">//小根堆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="进阶思考，自定义数据类型"><a href="#进阶思考，自定义数据类型" class="headerlink" title="进阶思考，自定义数据类型"></a>进阶思考，自定义数据类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; <span class="comment">//是&gt; 而不是&lt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, cmp1&gt; q4;<span class="comment">//自定义小根堆</span></span><br><span class="line">    priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, cmp2&gt; q5;<span class="comment">//自定义大根堆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语法之unordered_map的4种遍历方式</title>
    <url>/2023/11/46b9beb2691f.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="方式一：值传递遍历"><a href="#方式一：值传递遍历" class="headerlink" title="方式一：值传递遍历"></a>方式一：值传递遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="方式二：引用传递遍历"><a href="#方式二：引用传递遍历" class="headerlink" title="方式二：引用传递遍历"></a>方式二：引用传递遍历</h2><blockquote>
<p>注意：要加const</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*const加里面也是可以的*/</span></span><br><span class="line"><span class="keyword">for</span>(pair&lt;<span class="type">const</span> <span class="type">int</span>, <span class="type">int</span>&gt;&amp; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="方式三：使用迭代器遍历"><a href="#方式三：使用迭代器遍历" class="headerlink" title="方式三：使用迭代器遍历"></a>方式三：使用迭代器遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式四：结构化绑定-c-17特性"><a href="#方式四：结构化绑定-c-17特性" class="headerlink" title="方式四：结构化绑定(c++17特性)"></a>方式四：结构化绑定(c++17特性)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*值传递*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [k, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*引用传递*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [k, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其中，如果只想使用键，值可以用_代替*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[k, _]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*同理，如果指向只用值，键可以用_代替*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一道有意思的算法题</title>
    <url>/2023/11/ffae31d2f853.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="给你一个从0开始的递增数组，将其随机打乱成另一个数组并返回。-字节"><a href="#给你一个从0开始的递增数组，将其随机打乱成另一个数组并返回。-字节" class="headerlink" title="给你一个从0开始的递增数组，将其随机打乱成另一个数组并返回。#字节#"></a>给你一个从0开始的递增数组，将其随机打乱成另一个数组并返回。#字节#</h2><blockquote>
<ol>
<li><p>要求使用O(1)空间内解决该问题</p>
</li>
<li><p>解决交换的次数越多随机数随到已经交换的下标的可能性越大的问题</p>
<p>该算法已有标准实现，可以自己看看</p>
</li>
</ol>
</blockquote>
<p>单纯从题目不加限制条件的角度来做，可以想到暴力法。标准实现还得看洗牌算法。</p>
<ol>
<li><strong>暴力法</strong>:申请另一个数组</li>
<li><strong>Fisher-Yates 洗牌算法</strong>：</li>
</ol>
<blockquote>
<p>我们可以在移除 <code>waiting</code> 的第 <code>k</code>个元素时，将第 <code>k</code>个元素与数组的最后 <code>1</code>个元素交换，然后移除交换后数组的最后 <code>1</code>个元素，这样我们只需要 <code>O(1)</code> 的时间复杂度即可完成移除第 <code>k</code> 个元素的操作。此时，被移除的交换后数组的最后 <code>1</code> 个元素即为我们根据随机下标获取的元素。</p>
<p>在此基础上，我们也可以不移除最后 <code>1</code> 个元素，而直接将其作为乱序后的结果，并更新待乱序数组的长度，从而实现数组的原地乱序。因为我们不再需要从数组中移除元素，所以也可以将第 <code>k</code> 个元素与第 <code>1</code> 个元素交换。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码同下</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Knuth 洗牌算法</strong>：</li>
</ol>
<blockquote>
<p>在 <code>O(n)</code> 复杂度内等概率返回某个方案。</p>
<p>具体的，我们从前往后尝试填充 <code>[0,n−1]</code> 该填入什么数时，通过随机当前下标与（剩余的）哪个下标进行值交换来实现。</p>
<p>对于下标 <code>x</code> 而言，我们从 <code>[x,n−1]</code> 中随机出一个位置与 <code>x</code> 进行值交换，当所有位置都进行这样的处理后，我们便得到了一个公平的洗牌方案。</p>
<p>这样能确保每个元素在每个位置的概率都是<code>1/n</code>。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">this</span>-&gt;original.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">copy</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), original.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">copy</span>(original.<span class="built_in">begin</span>(), original.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="built_in">rand</span>() % (nums.<span class="built_in">size</span>() - i);</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; original;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>解答参考链接：</p>
<p>[1]:<a href="https://blog.csdn.net/cy973071263/article/details/128818181">https://blog.csdn.net/cy973071263/article/details/128818181</a>	“参考链接1”<br>[2]:<a href="https://blog.csdn.net/defaultbyzt/article/details/128628119">https://blog.csdn.net/defaultbyzt/article/details/128628119</a>	“参考链接2”<br>[3]:<a href="https://www.bilibili.com/read/cv26024350/">https://www.bilibili.com/read/cv26024350/</a>	“参考链接3”<br>[4]:<a href="https://leetcode.cn/problems/shuffle-an-array/">https://leetcode.cn/problems/shuffle-an-array/</a>	“参考链接4”</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的：从根儿上理解MySQL》笔记</title>
    <url>/2023/11/7903b9c54b9d.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote>
<p>作者联系方式：</p>
<p>微信： xiaohaizi4919</p>
<p>公众号：我们都是小青蛙</p>
</blockquote>
<ul>
<li>该书只是介绍 MySQL 内核的一些核心概念的小白进阶书籍</li>
<li>学习方法：<strong>不要跳着看！！！</strong></li>
</ul>
<h2 id="1-重新认识MySQL"><a href="#1-重新认识MySQL" class="headerlink" title="1. 重新认识MySQL"></a>1. 重新认识MySQL</h2><ul>
<li><p>MySQL也是基于<strong>客户端／服务器架构</strong>的。</p>
</li>
<li><p>大概流程是：用户使用MySQL客户端来连接MySQL服务器，成功连接之后向服务器进程发送请求并得到回复的</p>
<p>过程。</p>
</li>
<li><p>MySQL服务器处理客户端请求的流程如下图1所示</p>
<ul>
<li><img src="/my_images/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9A%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MySQL%E3%80%8B%E7%AC%94%E8%AE%B0/1.png"></li>
</ul>
</li>
<li><p>为什么叫<code>引擎</code>呢？因为这个名字更拉风～以前叫做<code>表处理器</code>。为了管理方便，人们把 <strong>连接管理 、 查询缓存 、 语法解析 、 查询优化</strong> 这些并不涉及<strong>真实数据存储</strong>的功能划分为 MySQL server 的功能，把真实存取数据的功能划分为 <strong>存储引擎</strong> 的功能。（有没有很熟悉的操作？网络的分层结构也是如此，下层对上层提供服务，上层依赖下层）</p>
</li>
<li><p>MySQL支持非常多种存储引擎，最常用的就是 <strong>InnoDB 和 MyISAM</strong> ，有时会提一下 <strong>Memory</strong> 。<strong>默认的存储引擎为</strong> <strong>InnoDB</strong> 。</p>
</li>
<li><p>存储引擎是负责对表中的数据进行提取和写入工作的，<strong>我们可以为不同的表设置不同的存储引擎</strong>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p>
</li>
</ul>
<h2 id="2-MySQL的调控按钮-启动选项和系统变量"><a href="#2-MySQL的调控按钮-启动选项和系统变量" class="headerlink" title="2. MySQL的调控按钮-启动选项和系统变量"></a>2. MySQL的调控按钮-启动选项和系统变量</h2><ul>
<li>在程序启动时指定的设置项也称之为<strong>启动选项（startup options）</strong>，这些选项控制着程序启动后的行为。</li>
<li>所以在启动服务器程序的命令行后边指定启动选项的通用格式就是这样的：<code>--启动选项1[=值1] --启动选项2[=值2] ... --启动选项n[=值n]</code>，需要注意，<strong>选项名、&#x3D;、选项值之间不可以有空白字符</strong>。</li>
<li>每个MySQL程序都有许多不同的选项。大多数程序提供了一个<code>--help</code>选项，你可以查看该程序支持的全部启动选项以及它们的默认值。例如，使用 <code>mysql --help</code> 可以看到 mysql 程序支持的启动选项， <code>mysqld_safe --help</code> 可以看到 mysqld_safe 程序支持的启动选项。查看 mysqld 支持的启动选项有些特别，需要使用 <code>mysqld --verbose --help</code> 。</li>
<li><code>启动选项</code> 是在程序启动时我们程序员传递的一些参数，而 <code>系统变量</code> 是影响服务器程序运行行为的变量，它们之间的关系如下：<ul>
<li>大部分的系统变量都可以被当作启动选项传入。</li>
<li>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code> 、 <code>character_set_client</code> 啥的。</li>
<li>有些启动选项也不是系统变量，比如 defaults-file 。</li>
</ul>
</li>
<li>为了让我们更好的了解服务器程序的运行情况， MySQL 服务器程序中维护了好多关于程序运行状态的变量，它们被称为 <code>状态变量</code> 。由于 <code>状态变量</code> 是用来显示服务器程序运行状况的，所以它们的值只能由<strong>服务器程序自己来设置</strong>，我们程序员是不能设置的。与 <code>系统变量</code> 类似， <code>状态变量</code> 也有 <code>GLOBAL</code> 和 <code>SESSION</code> 两个作用范围的，所以查看 状态变量 的语句可以这么写：<code>SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</code></li>
</ul>
<h2 id="3-字符集和比较规则"><a href="#3-字符集和比较规则" class="headerlink" title="3. 字符集和比较规则"></a>3. 字符集和比较规则</h2><ul>
<li>在计算机中只能存储二进制数据，那该怎么存储字符串呢？当然是建立字符与二进制数据的映射关系了，建立这个关系最起码要搞清楚两件事儿：<ol>
<li>你要把哪些字符映射成二进制数据？<br>也就是界定清楚<code>字符范围</code>。</li>
<li>怎么映射？<br>将一个字符映射成一个二进制数据的过程也叫做 <code>编码</code> ，将一个二进制数据映射到一个字符的过程叫做 <code>解码</code> 。<br>人们抽象出一个 <code>字符集</code> 的概念来描述某个字符范围的编码规则。</li>
</ol>
</li>
<li>字符集表示字符的范围以及编码规则后，怎么比较两个字符的大小呢？最容易想到的就是直接比较这两个字符对应的二进制编码的大小，这种简单的比较规则也可以被称为二进制比较规则，英文名为 binary collation 。二进制比较规则是简单，但有时候并不符合现实需求，比如在很多场合对于英文字符我们都是不区分大小写的，也就是说 ‘a’ 和 ‘A’ 是相等的，在这种场合下就不能简单粗暴的使用二进制比较规则了。对于某一种字符集来说，比较两个字符大小的规则可以制定出很多种，也就是说<strong>同一种字符集可以有多种比较规则</strong>。</li>
<li>常用的重要字符集<ul>
<li>ASCII 字符集：共收录128个字符，占1字节。</li>
<li>ISO 8859-1 字符集：共收录256个字符，是在 ASCII 字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以使用1个字节来进行编码。这个字符集也有一个别名 latin1 。</li>
<li>GB2312 字符集：收录汉字6763个，其他文字符号682个。兼容 ASCII 字符集，所以编码方式是：如果该字符在 ASCII 字符集中，则采用1字节编码。否则采用2字节编码。可以通过第一个字节是否属于0-127来判断1字节还是2字节编码。</li>
<li>GBK 字符集：在收录字符范围上对 GB2312 字符集作了扩充，编码方式上兼容 GB2312 。占2字节。</li>
<li>utf8 字符集：收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容 ASCII 字符集，采用变长编码方式，编码一个字符需要使用1～4个字节。<br>其实准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。</li>
</ul>
</li>
<li>MySQL 支持很多种字符集，查看 MySQL 中查看支持的字符集和比较规则的语句如下：<br><code>SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</code><br><code>SHOW COLLATION [LIKE 匹配的模式];</code></li>
<li>常用的一些字符使用1～3个字节就可以表示了。而在 MySQL 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计MySQL 的大叔偷偷的定义了两个概念：<ul>
<li>utf8mb3 ：阉割过的 utf8 字符集，只使用1～3个字节表示字符。在 MySQL 中 utf8 是 utf8mb3 的别名。</li>
<li>utf8mb4 ：正宗的 utf8 字符集，使用1～4个字节表示字符。</li>
</ul>
</li>
<li>MySQL 有4个级别的字符集和比较规则，分别是：服务器级别、数据库级别、表级别、列级别。<ul>
<li>如果创建或修改列时没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则。</li>
<li>如果创建或修改表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则。</li>
<li>如果创建或修改数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则。</li>
</ul>
</li>
<li>如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果。就像我们经常看到的乱码一样。</li>
<li>从发送请求到接收结果过程中发生的字符集转换：<ul>
<li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li>
<li>服务器将客户端发送来的字节串采用 character_set_client 代表的字符集进行解码，将解码后的字符串再按照 character_set_connection 代表的字符集进行编码。</li>
<li>如果 character_set_connection 代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从 character_set_connection 代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li>
<li>将从某个列获取到的字节串从该列使用的字符集转换为 character_set_results 代表的字符集后发送到客户端。</li>
<li>客户端使用操作系统的字符集解析收到的结果集字节串。</li>
<li>一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</li>
</ul>
</li>
</ul>
<h2 id="4-InnoDB记录结构"><a href="#4-InnoDB记录结构" class="headerlink" title="4. InnoDB记录结构"></a>4. InnoDB记录结构</h2><ul>
<li><p>MySQL 服务器上负责对表中数据的读取和写入工作的部分是 <code>存储引擎</code> ，而服务器又支持不同类型的存储引擎，比如 InnoDB 、 MyISAM 、 Memory 啥的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，<strong>真实数据在不同存储引擎中存放的格式一般是不同的</strong>。由于 InnoDB 是 MySQL 默认的存储引擎，本节以 <strong>InnoDB 引擎</strong>的内部实现为例，了解了一个存储引擎的数据存储结构之后，其他的存储引擎都是依葫芦画瓢。</p>
</li>
<li><p>InnoDB页：<br>InnoDB 采取的方式是：将数据划分为若干个页，<strong>以页作为磁盘和内存之间交互的基本单位</strong>，InnoDB中页的大小 一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p>
</li>
<li><p>InnoDB行格式：我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 <code>行格式</code> 或者 <code>记录格式</code> 。<br>设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、Dynamic 和 Compressed 行格式。</p>
</li>
<li><p>COMPACT行格式：</p>
<ul>
<li>一条完整的记录其实可以被分为 <strong>记录的额外信息</strong> 和 <strong>记录的真实数据</strong> 两大部分。<strong>记录的额外信息</strong>是服务器为了描述这条记录而不得不额外添加的一些信息。</li>
<li><img src="/my_images/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9A%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MySQL%E3%80%8B%E7%AC%94%E8%AE%B0/2.png"></li>
</ul>
</li>
<li><p>Redundant行格式：</p>
<ul>
<li><p>Redundant 行格式是 MySQL5.0 之前用的一种行格式，也就是说它已经非常老了，但是本着知识完整性的角度还是要提一下，大家乐呵乐呵的看就好。</p>
</li>
<li><p><img src="/my_images/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9A%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MySQL%E3%80%8B%E7%AC%94%E8%AE%B0/3.png"></p>
</li>
<li><p>行溢出：MySQL中一个页的大小一般是 16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中。这种现象就叫<strong>行溢出</strong>。<br>那发生 <strong>行溢出</strong> 的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生 行溢出 ？<br><strong>MySQL 中规定一个页中至少存放两行记录</strong>，至于为什么这么规定我们之后再说，这个规定就会对行溢出的判断造成的影响。至少两条记录。</p>
</li>
</ul>
</li>
<li><p>Dynamic和Compressed行格式：<br>这两种行格式类似于 COMPACT行格式 ，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实据处存储字符串的前768个字节，而是<strong>把所有的字节都存储到其他页面中</strong>，只在记录的真实数据处存储其他页面的地址。<br>另外， Compressed 行格式会采用<strong>压缩算法</strong>对页面进行压缩。<br>MySQL5.7的默认行格式就是 Dynamic 。</p>
</li>
</ul>
<h2 id="5-InnoDB数据页结构"><a href="#5-InnoDB数据页结构" class="headerlink" title="5. InnoDB数据页结构"></a>5. InnoDB数据页结构</h2><ul>
<li><p>一般来说，InnoDB中一个页的大小一般是16KB。InnoDB 为了不同的目的而设计了<strong>许多种不同类型的 页</strong> ，比如存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 INODE 信息的页，存放 undo 日志信息的页等等。</p>
</li>
<li><p>官方称存放记录的页为<strong>索引（ INDEX ）页</strong>，而这些表中的记录就是我们日常口中所称的 <strong>数据</strong> ，所以目前还是叫这种存放记录的页为 <strong>数据页</strong>。</p>
</li>
<li><p>数据页结构图如下，从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。<br><img src="/my_images/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9A%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MySQL%E3%80%8B%E7%AC%94%E8%AE%B0/4.png"></p>
</li>
<li><p>User Records 部分：<br>我们自己存储的记录会按照我们指定的 <strong>行格式</strong> 存储到 <strong>User Records</strong> 部分。<br>在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 <strong>Free Space</strong> 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。<br>记录在页中按照<strong>主键值由小到大</strong>顺序串联成一个<strong>单链表</strong>。</p>
</li>
<li><p>Page Directory（页目录）：</p>
<ol>
<li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li>
<li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li>
<li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近 <code>页</code> 的尾部的地方，这个地方就是所谓的 Page Directory ，也就是 页目录 （此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为 槽 （英文名： Slot ），所以这个页面目录就是由 槽 组成的。<br>设计 InnoDB 的大叔们对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。<br>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的 <strong>二分法</strong> 来进行快速查找。在一个数据页中查找指定主键值的记录的过程分为两步：</li>
<li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li>
<li>通过记录的 next_record 属性遍历该槽所在的组中的各个记录。</li>
</ol>
</li>
<li><p>Page Header（页面头部）：<br>占用固定的 56 个字节，专门针对 <strong>数据页</strong> 记录的各种状态信息。</p>
</li>
<li><p>File Header（文件头部）：<br>占用固定的 38 个字节，针对各种类型的页都通用。也就是说不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁等等。</p>
<ul>
<li>FIL_PAGE_SPACE_OR_CHKSUM：代表当前页面的校验和（checksum）。</li>
<li>FIL_PAGE_OFFSET：每一个 页 都有一个单独的页号，就跟你的身份证号码一样， InnoDB 通过页号来可以唯一定位一个 页 。</li>
<li>FIL_PAGE_TYPE：代表当前 页 的类型。其中，存放记录的数据页的类型其实是 <code>FIL_PAGE_INDEX</code> ，也就是所谓的 <code>索引页</code> 。</li>
<li>FIL_PAGE_PREV 和 FIL_PAGE_NEXT：分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了。<strong>注意：并不是所有类型的页都有上一个和下一个页的属性。</strong></li>
</ul>
</li>
<li><p>File Trailer：<br>由 8 个字节组成，与 File Header 类似，都是所有类型的页通用的。其中，前4个字节代表页的校验和，后4个字节代表页面被最后修改时对应的日志序列位置（LSN），也是为了校验页的完整性的。</p>
</li>
</ul>
<h2 id="6-快速查询的秘籍-B-树索引"><a href="#6-快速查询的秘籍-B-树索引" class="headerlink" title="6. 快速查询的秘籍-B+树索引"></a>6. 快速查询的秘籍-B+树索引</h2><ul>
<li><p>没有索引的时候是怎么查找记录的：</p>
<ul>
<li><strong>在一个页中的查找：</strong><br>以主键为搜索条件：在 <strong>页目录</strong> 中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。<br>以其他列作为搜索条件：只能从 <strong>最小记录</strong> 开始依次遍历单链表中的每条记录，效率很低。</li>
<li><strong>在很多页中查找：</strong><br>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。显然是超级耗时的。</li>
</ul>
</li>
<li><p>一个简单的索引方案：</p>
<blockquote>
<p>查找一些记录时为什么要遍历所有的数据页呢？<br>因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 <strong>不得不</strong> 依次遍历所有的数据页。</p>
</blockquote>
<p>想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下边这些事儿：</p>
<ul>
<li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立，这个过程我们也可以称为 <strong>页分裂</strong> 。</li>
<li>给所有的页建立一个目录项。由于数据页的编号可能并不是连续的，那么为了从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录（这个 <strong>目录</strong> 有一个别名，称为 <strong>索引</strong> ），每个页对应一个目录项，每个目录项包括两个部分：页的用户记录中最小的主键值，我们用 key 来表示。页号，我们用 page_no 表示。</li>
</ul>
</li>
<li><p>InnoDB中的索引方案：<br>设计 InnoDB 的大叔们需要一种可以灵活管理所有 <code>目录项</code> 的方式。<br>他们灵光乍现，忽然发现这些 <code>目录项</code> 其实长得跟我们的用户记录差不多，只不过 <code>目录项</code> 中的两个列是 <code>主键</code> 和 <code>页号</code> 而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为 <code>目录项记录</code> 。那 InnoDB 怎么区分一条记录是普通的 <code>用户记录</code> 还是 <code>目录项记录</code> 呢？通过记录头信息里的record_type 属性。<br><img src="/my_images/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9A%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MySQL%E3%80%8B%E7%AC%94%E8%AE%B0/5.png"><br>如果我们表中的数据非常多则会产生很多存储 <code>目录项记录</code> 的页，那我们怎么根据主键值快速定位一个存储 <code>目录项记录</code> 的页呢？<br>为这些存储 <code>目录项记录</code> 的页再生成一个更高级的目录，就像是一个<strong>多级目录</strong>一样，大目录里嵌套小目录，小目录里才是实际的数据。</p>
</li>
<li><p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到 <strong>B+ 树</strong>这个数据结构中了，所以我们也称这些数据页为 <strong>节点</strong> 。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为 <strong>叶子节点</strong> 或 <strong>叶节点</strong> ，其余用来存放 目录项 的节点称为 <strong>非叶子节点</strong> 或者 内节点 ，其中 B+ 树最上边的那个节点也称为 <strong>根节点</strong> 。</p>
</li>
<li><p>InnoDB规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。</p>
</li>
<li><p><strong>聚簇索引</strong>：InnoDB 存储引擎会自动的为我们创建聚簇索引。在 InnoDB 存储引擎中， 聚簇索引 就是数据的存储方式（<strong>所有的用户记录都存储在了 叶子节点</strong> ），也就是所谓的<strong>索引即数据，数据即索引</strong>。注意：聚簇索引只能在搜索条件是主键值时才能发挥作用。</p>
</li>
<li><p><strong>二级索引</strong>（secondary index，也叫辅助索引）：针对以别的列作为搜索条件。<br>我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。比方说我们用 c2 列的大小作为数据页、页中记录的排序规则，再建一棵 B+ 树，和聚簇索引的区别是：</p>
<ul>
<li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是 <code>c2列+主键</code> 这两个列的值。</li>
<li>目录项记录中不再是 <code>主键+页号</code> 的搭配，而变成了 <code>c2列+页号</code> 的搭配。</li>
<li>搜索过程时，多了一步：必须再根据主键值去<strong>聚簇索引</strong>中再查找一遍完整的用户记录。这个过程也被称为 <code>回表</code> 。</li>
</ul>
</li>
<li><p><strong>联合索引</strong>：<br>以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>每条 目录项记录 都由 c2 、 c3 、 页号 这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序。</li>
<li>B+ 树叶子节点处的用户记录由 c2 、 c3 和主键 c1 列组成。</li>
<li>建立 联合索引 只会建立1棵 B+ 树，而为c2和c3列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立2棵 B+ 树。</li>
</ul>
</li>
<li><p>MyISAM中的索引方案简单介绍：<strong>索引是索引、数据是数据。</strong><br>虽然也使用树形结构，但是却将索引和数据分开存储。<br>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为 <code>数据文件</code> 。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。<br>使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为 <code>索引文件</code> 的另一个文件中。 MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是 主键值 + 行号 的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！这说明在 MyISAM 中都需要进行一次 <code>回表</code> 操作，意味着 MyISAM 中建立的索引相当于全部都是 <code>二级索引</code> ！<br>对其它的列分别建立索引或者建立联合索引，原理和 InnoDB 中的索引差不多，不过在叶子节点处存储的是 <code>相应的列 + 行号</code> 。这些索引也全部都是 <code>二级索引</code> 。</p>
</li>
<li><p>使用 MySQL 语句去建立、删除索引：<br>InnoDB 和 MyISAM 会自动为<strong>主键</strong>或者<strong>声明为 <code>UNIQUE</code> 的列</strong>去自动建立 B+ 树索引。<br>创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：<br><code>CREATE TALBE 表名 (</code><br> <code>各种列的信息 ··· ,</code><br> <code>[KEY|INDEX] 索引名 (需要被索引的单个列或多个列)</code><br><code>)</code></p>
<p>在修改表结构的时候添加索引：<br><code>ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</code></p>
<p>在修改表结构的时候删除索引：<br><code>ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;</code></p>
<p>举例：在创建 index_demo 表的时候就为 c2 和 c3 列添加一个 联合索引 ，可以这么写建表语句：<br><code>CREATE TABLE index_demo(</code><br> <code>c1 INT,</code><br> <code>c2 INT,</code><br> <code>c3 CHAR(1),</code><br> <code>PRIMARY KEY(c1),</code><br> <code>INDEX idx_c2_c3 (c2, c3)</code><br><code>);</code></p>
<p>建议索引名以 <code>idx_</code> 为前缀，后边跟着需要建立索引的列名，多个列名之间用<strong>下划线 _</strong> 分隔开。</p>
</li>
</ul>
<h2 id="7-B-树索引的使用"><a href="#7-B-树索引的使用" class="headerlink" title="7. B+树索引的使用"></a>7. B+树索引的使用</h2><ul>
<li><p>索引的代价：空间上，内节点比较耗费空间；时间上，进行增、删、改操作时，都需要去修改各个 B+ 树索引。所以，没事就<strong>别瞎建立索引</strong>。</p>
</li>
<li><p>B+树索引适用的条件：</p>
<ul>
<li><p>全值匹配：如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配。</p>
</li>
<li><p>匹配左边的列：如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。因为排序规则是前一个列相同，则按照下一个列进行排序。如果进行跳列查询，就用不到联合索引了。</p>
</li>
<li><p>匹配列前缀：字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的。如果只给出后缀或者中间的某个字符串，那就用不上索引了，也就无法快速定位记录位置了。注意：查找后缀的搜索条件，可以更改数据存储的顺序（逆序存储），然后使用前缀匹配，来优化查找效率。</p>
</li>
<li><p>匹配范围值：所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。<strong>注意：</strong>在使用<strong>联合索引</strong>进行范围查找的时候，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引。</p>
</li>
<li><p>精确匹配某一列并范围匹配另外一列：对于同一个<strong>联合索引</strong>来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找。</p>
</li>
<li><p>用于排序：如果 <code>ORDER BY</code> 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤。<strong>注意：</strong>对于 <code>联合索引</code> 有个问题需要注意， <code>ORDER BY</code> 的子句后边的列的顺序也必须按照索引列的顺序给出。</p>
<p><strong>特别注意</strong>，不可以使用索引进行排序的几种情况：</p>
<ul>
<li>ASC、DESC混用：对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 ASC 规则排序，要么都是 DESC 规则排序。混用排序，不能高效使用索引，不如直接使用文件排序。</li>
<li>WHERE子句中出现非排序使用到的索引列。</li>
<li>排序列包含非同一个索引的列：有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序。</li>
<li>排序列使用了复杂的表达式：要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式。例如：使用 <code>UPPER</code> 函数修饰过的列就不是单独的列，这样就无法使用索引进行排序。</li>
</ul>
</li>
<li><p>用于分组：有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。如果分组顺序和我们的 B+ 树中的索引列的顺序是一致的，而我们的 B+ 树索引又是按照索引列排好序的，这正好就可以直接使用 B+ 树索引进行分组。</p>
</li>
</ul>
</li>
<li><p>回表的代价：<br>使用联合索引的查询有这么两个特点：</p>
<ul>
<li>会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引。</li>
<li>访问二级索引使用 <code>顺序I/O</code> ，访问聚簇索引使用 <code>随机I/O</code> 。</li>
</ul>
<p><strong>需要回表的记录越多，使用二级索引的性能就越低，所以让某些查询宁愿使用<code>全表扫描</code>也不使用 <code>二级索引+回表</code>。</strong></p>
<p>那什么时候采用全表扫描的方式，什么时候使用采用 二级索引 + 回表 的方式去执行查询呢？<br>这个就是传说中的<strong>查询优化器</strong>做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索引 + 回表 的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。</p>
<p>覆盖索引：为了彻底告别 <code>回表</code> 操作带来的性能损耗，建议最好在查询列表里只包含索引列。把这种只需要用到索引的查询方式称为覆盖索引。例如：建立了联合索引 <code>idx_name_birthday_phone_number</code> ，而查询也只涉及索引列，不需要回表操作。<br><code>SELECT name, birthday, phone_number FROM person_info WHERE name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39;;</code><br>当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是我们很不鼓励用 * 号作为查询列表，最好把我们需要查询的列依次标明。</p>
</li>
<li><p>如何挑选索引：</p>
<p><strong>只为用于搜索、排序或分组的列创建索引</strong>。</p>
<p><strong>考虑列的基数</strong>： <code>列的基数</code> 指的是某一列中不重复数据的个数。最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p>
<p><strong>索引列的类型尽量小</strong>： <code>类型大小</code> 指的就是该类型表示的数据范围的大小。对于表的主键来说更加适用。数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）。数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I&#x2F;O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p>
<p><strong>索引字符串值的前缀</strong>：索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案，只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。<strong>只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</strong><br>如果使用了索引列前缀，比方说前边只把 name 列的前10个字符放到了二级索引中，那么 <code>SELECT * FROM person_info ORDER BY name LIMIT 10;</code> 查询就只能使用文件排序了。</p>
<p><strong>让索引列在比较表达式中单独出现</strong>：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出 现的话，是用不到索引的。</p>
<p><strong>主键插入顺序</strong>：如果主键不按顺序插入，产生的页面分裂和记录移位就意味着：<strong>性能损耗！</strong>所以，建议让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入。</p>
<p><strong>避免冗余和重复索引</strong>。</p>
</li>
</ul>
<h2 id="8-数据的家-MySQL的数据目录"><a href="#8-数据的家-MySQL的数据目录" class="headerlink" title="8. 数据的家-MySQL的数据目录"></a>8. 数据的家-MySQL的数据目录</h2><h2 id="9-n"><a href="#9-n" class="headerlink" title="9. n"></a>9. n</h2><h2 id="10-n"><a href="#10-n" class="headerlink" title="10. n"></a>10. n</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://juejin.cn/book/6844733769996304392">https://juejin.cn/book/6844733769996304392</a>	“掘金小册”</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux僵尸进程相关问题</title>
    <url>/2023/11/f73dfc9b8e43.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="僵尸进程的产生："><a href="#僵尸进程的产生：" class="headerlink" title="僵尸进程的产生："></a>僵尸进程的产生：</h2><p>Linux下进程有种状态叫做僵尸状态</p>
<p>原因是父进程<code>fork()</code>出来的子进程结束之后，内核会给父进程发送一个<code>SIGCHLD信号</code></p>
<blockquote>
<p>这个SIGCHLD信号的作用是，及时通知父进程子进程的退出，让父进程通过一系列手段将他回收</p>
<p>回收的意义:</p>
<ol>
<li>避免僵尸进程的产生，内存泄漏</li>
<li>且使得父进程能拿到子进程的退出状态，进行相应处理</li>
</ol>
</blockquote>
<p>如果父进程没有忽略这个信号(设置SIG_IGN)，也没有等待(wait)子进程，而且结束的也比子进程晚(不能托管被init1号进程领养)，并且也没有handler捕捉这个信号，那子进程就会进入僵尸状态; 维护者自己的task_struct开销，这也是一种内存泄露;</p>
<h2 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h2><ol>
<li><p>父进程阻塞调用wait()。</p>
<p>调用细节：进程一旦调用了wait，就立即<strong>阻塞自己</strong>，由wait自动分析是否当前进程的<strong>某个</strong>子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会<strong>一直阻塞</strong>在这里，直到有一个出现为止。</p>
<p>缺点：显然wait的调用是非常不合理的，阻塞时等待会让父进程干不了别的事情。</p>
</li>
<li><p>父进程非阻塞调用waitpid()。</p>
<p>根据源码的观察，不难发现，其实wait就是waitpid的一种封装。</p>
<p>缺点：waitpid虽然不会阻塞时等待，但是也需要占用cpu资源，定期的轮训waitpid看看有没有子进程处于僵尸状态，以便将他回收，也是有一定开销的。</p>
</li>
<li><p>SIGCHLD信号。</p>
<blockquote>
<p>其实我们的子进程每次终止时<strong>内核</strong>都会给父进程发送一个<strong>SIGCHLD信号</strong>，如果<strong>父进程没有处理这个信号，也没有等待(wait)子进程</strong>，那他就会进入僵尸状态</p>
</blockquote>
<p>既然这样，我们可以用<strong>signal()函数+waitpid()接口</strong>处理一下这个信号，答到一个子进程退出之后，主动通知父进程将其回收的<strong>异步通知作用</strong>！(显然效率是比父进程主动wait和waitpid这种同步处理高！)</p>
<p>注意，handler中使用while循环处理回收任务的原因是:SIGCHILD是个非可靠信号！</p>
<p>一个父进程可能有很多子进程，如果多个子进程同时退出，SIGCHILD会出现信号丢失(只存在1个)。如果用if处理，也就只处理一个子进程。剩下的子进程也就变成了僵尸进程!</p>
<p>因此我们发现有子进程退出，就用while循环来处理，如果恰好多个子进程退出，即便信号丢失，我们也能while通过waitpid的返回值不断释放他们，即便只有一个子进程退出，第二次循环waitpid会返回0，我们也会跳出循环！</p>
</li>
<li><p>SIG_IGN信号。</p>
<p>解决僵尸进程还有一个方式，就是让他变为“孤儿进程”，也就是init1号进程领养托管，进而释放这个子进程的资源！</p>
<p>除了让父进程退出的比子进程早之外，我们可以通过如下操作，将SIGCHLD信号的处理方式设置为SIG_IGN–&gt;<strong>忽略</strong>，这样代表父进程忽视了这个信号，子进程相当于被弃养，会被init1号进程领养。</p>
<p>这样可让内核把僵尸子进程转交给init1号进程去处理释放，省去了父进程wait这个子进程的麻烦。</p>
<p>这个小技巧常常被用于提升并发服务器的性能！</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://blog.csdn.net/wtl666_6/article/details/129513009">https://blog.csdn.net/wtl666_6/article/details/129513009</a>	“参考资料1”</p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>这是在测试</title>
    <url>/2023/09/e5cb20f8607e.html</url>
    <content><![CDATA[<h1 id="test-my-blog"><a href="#test-my-blog" class="headerlink" title="test my blog"></a>test my blog</h1><p>test my blogtest my blog</p>
]]></content>
      <categories>
        <category>零零碎碎</category>
      </categories>
  </entry>
  <entry>
    <title>如何解决TCP粘包问题</title>
    <url>/2023/11/8c2faec0a14b.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="TCP粘包问题"><a href="#TCP粘包问题" class="headerlink" title="TCP粘包问题"></a>TCP粘包问题</h2><ul>
<li>TCP数据粘包是指发送方连续发送多个数据包时，接收方在接收时会将多个数据包粘成一个大的数据包，造成数据处理上的困难。</li>
<li>首先回忆一下，TCP的三大特点：面向连接、可靠的、基于字节流的。</li>
<li>显然，问题出在<code>TCP是基于字节流的</code>，所以并不会明确TCP包的边界。而UDP是基于包的，所以不会出现这个问题。</li>
</ul>
<h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><blockquote>
<p>总的原则：既然没有边界，那么加上边界识别的机制那就完活了。</p>
</blockquote>
<ol>
<li><p>设置消息边界：在消息的末尾添加特殊字符或者标志符号，在接收方收到消息时根据特殊字符或标志符号来分隔消息。</p>
</li>
<li><p>消息长度：在消息的开头添加消息长度信息，在接收方接收到消息时先读取消息长度，再读取对应长度的消息内容。</p>
</li>
<li><p>延迟发送：发送方在发送数据时，可以采用延迟发送的方式，即等待一段时间再发送，以此避免多个数据包同时发送造成粘包。</p>
</li>
<li><p>使用固定长度的数据包：发送方发送固定长度的数据包，接收方按照固定长度来接收数据包，以此避免粘包问题。 </p>
<p>举例：在Qt中，可以通过设置socket的读取缓存区大小、设置消息边界符号、消息长度信息等方式来防止TCP数据粘包。例如，可以使用以下代码设置消息边界符号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QTcpSocket *socket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">socket-&gt;<span class="built_in">setReadBufferSize</span>(<span class="number">1024</span>); <span class="comment">//设置读取缓存区大小为1024字节</span></span><br><span class="line">socket-&gt;<span class="built_in">write</span>(<span class="string">&quot;message1\n&quot;</span>); <span class="comment">//发送消息1</span></span><br><span class="line">socket-&gt;<span class="built_in">write</span>(<span class="string">&quot;message2\n&quot;</span>); <span class="comment">//发送消息2</span></span><br></pre></td></tr></table></figure>

<p>在接收方，可以使用以下代码来接收数据并根据消息边界符号分隔消息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (socket-&gt;<span class="built_in">bytesAvailable</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    QByteArray data = socket-&gt;<span class="built_in">readLine</span>(); <span class="comment">//读取一行数据</span></span><br><span class="line">    QString message = <span class="built_in">QString</span>(data).<span class="built_in">trimmed</span>(); <span class="comment">//去除换行符</span></span><br><span class="line">    <span class="comment">//处理接收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://blog.csdn.net/future_ai/article/details/130192182">https://blog.csdn.net/future_ai/article/details/130192182</a>	“参考链接1”</p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句相关问题</title>
    <url>/2023/11/f290346388e4.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="查询成绩表中每名学生成绩最高的课程和最大分数以及这个学生的名字"><a href="#查询成绩表中每名学生成绩最高的课程和最大分数以及这个学生的名字" class="headerlink" title="查询成绩表中每名学生成绩最高的课程和最大分数以及这个学生的名字"></a>查询成绩表中每名学生成绩最高的课程和最大分数以及这个学生的名字</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 给定成绩表t，表结构字段为(name, subject, score)</span><br><span class="line"></span><br><span class="line"># 使用子<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> name, <span class="built_in">max</span>(score) m <span class="keyword">from</span> t <span class="keyword">GROUP</span> <span class="keyword">BY</span> name) b, t</span><br><span class="line"><span class="keyword">where</span> t.name<span class="operator">=</span>b.name <span class="keyword">and</span> t.score<span class="operator">=</span>b.m</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>[1]:<a href="https://blog.csdn.net/zb199738/article/details/102767660">https://blog.csdn.net/zb199738/article/details/102767660</a>	“参考链接”</p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP常用状态码</title>
    <url>/2023/11/0896971b91c1.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-总体介绍"><a href="#0-总体介绍" class="headerlink" title="0. 总体介绍"></a>0. 总体介绍</h2><ul>
<li><p>在Web开发中，HTTP错误码是用来表示请求的处理状态的标准化方法。不同的错误码代表了不同的处理结果，帮助开发者和浏览器进行正确的处理和跳转。</p>
</li>
<li><p>HTTP错误码是用来表示请求处理状态的三位数字代码。常见的错误码包括200表示成功，404表示未找到，500表示服务器内部错误等。通过错误码，服务器和浏览器可以根据具体情况采取不同的处理方式。</p>
</li>
</ul>
<h2 id="1-1xx状态码"><a href="#1-1xx状态码" class="headerlink" title="1. 1xx状态码"></a>1. 1xx状态码</h2><h2 id="2-2xx状态码"><a href="#2-2xx状态码" class="headerlink" title="2. 2xx状态码"></a>2. 2xx状态码</h2><h2 id="3-3xx状态码"><a href="#3-3xx状态码" class="headerlink" title="3. 3xx状态码"></a>3. 3xx状态码</h2><h3 id="303-See-Other状态码"><a href="#303-See-Other状态码" class="headerlink" title="303 See Other状态码"></a>303 See Other状态码</h3><p><strong>定义：</strong></p>
<ul>
<li>HTTP错误码303 See Other表示请求已经被服务器接收，但需要进一步的操作才能完成请求。它通常用于POST请求的响应，告诉客户端应该使用GET方法重新发起请求。</li>
<li>例如，当用户提交一个表单后，服务器可能会返回303状态码，告诉浏览器应该使用GET方法重新请求一个新的URL，以防止用户刷新页面时重新提交表单。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li><p>重定向到新的资源。</p>
<p>当用户提交一个表单后，服务器可能会处理表单数据，并将用户重定向到一个新的URL，以显示处理结果。这时，服务器会返回303状态码，并在响应头中包含一个Location字段，指示新的URL。</p>
<p>浏览器收到这个响应后，会自动使用GET方法请求新的URL，然后显示新的页面。</p>
</li>
<li><p>重定向到其他网站。</p>
<p>有时候，服务器可能需要将用户重定向到其他网站。例如，当用户请求一个需要登录的页面时，服务器可能会返回303状态码，并在响应头中包含一个Location字段，指示登录页面的URL。</p>
<p>浏览器收到这个响应后，会自动使用GET方法请求登录页面，并在用户登录成功后，再次重定向到原来的页面。</p>
</li>
<li><p>防止表单重复提交。</p>
<p>当用户提交一个表单后，服务器可能会返回303状态码，并在响应头中包含一个Location字段，指示一个新的URL。这样，即使用户刷新页面，也不会重新提交表单。</p>
<p>浏览器收到这个响应后，会自动使用GET方法请求新的URL，从而避免了表单的重复提交。</p>
</li>
</ul>
<p><strong>如何正确处理303状态码：</strong></p>
<ul>
<li>服务器端处理<ul>
<li>当服务器接收到一个POST请求并完成处理后，应返回303状态码和一个Location字段，指示重定向的URL。</li>
<li>确保重定向的URL是有效的，并且能够正确处理GET请求。</li>
<li>考虑使用301或302状态码来替代303状态码，如果资源的移动是永久的或者是暂时的。</li>
</ul>
</li>
<li>客户端处理<ul>
<li>当浏览器收到303状态码时，应自动使用GET方法请求新的URL。</li>
<li>在处理重定向时，应注意处理循环重定向的情况，避免进入无限重定向的循环。</li>
</ul>
</li>
</ul>
<h2 id="4-4xx状态码"><a href="#4-4xx状态码" class="headerlink" title="4. 4xx状态码"></a>4. 4xx状态码</h2><h2 id="5-5xx状态码"><a href="#5-5xx状态码" class="headerlink" title="5. 5xx状态码"></a>5. 5xx状态码</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://blog.csdn.net/lsoxvxe/article/details/132150825">https://blog.csdn.net/lsoxvxe/article/details/132150825</a>	“参考链接1”</p>
<p>[2]:<a href="https://www.rfc-editor.org/rfc/rfc9110#status.303">https://www.rfc-editor.org/rfc/rfc9110#status.303</a>	“参考链接2官方”</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>URI和URL有什么区别</title>
    <url>/2023/11/d655b4fe2f15.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-概念"><a href="#0-概念" class="headerlink" title="0. 概念"></a>0. 概念</h2><ul>
<li>URI &#x3D; Uniform Resource Identifier 统一资源标志符</li>
<li>URL &#x3D; Uniform Resource Locator 统一资源定位符</li>
<li>URN &#x3D; Uniform Resource Name 统一资源名称</li>
</ul>
<h2 id="1-简介一下"><a href="#1-简介一下" class="headerlink" title="1. 简介一下"></a>1. 简介一下</h2><p>简单来说，就是URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI。</p>
<p>本来设想的的使用两种方法定位：1、URL，用地址定位；2、URN 用名称定位。</p>
<p>举个例子：去村子找个具体的人（URI），如果用地址：某村多少号房子第几间房的主人 就是URL， 如果用身份证号+名字 去找就是URN了。</p>
<p>原来uri包括url和urn，后来urn没流行起来，导致几乎目前所有的uri都是url。</p>
<p>三者之间几何关系如下：</p>
<img src="/my_images/URI和URL有什么区别/1.png" style="zoom:50%;" />



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://zhuanlan.zhihu.com/p/465487888">https://zhuanlan.zhihu.com/p/465487888</a>	“参考链接1”</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/12/d11128087057.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="0-设计模式简介"><a href="#0-设计模式简介" class="headerlink" title="0. 设计模式简介"></a>0. 设计模式简介</h2><blockquote>
<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 </p>
<p>设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
</blockquote>
<h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。</p>
<p>这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。还有，另一类设计模式：J2EE 设计模式。</p>
<ul>
<li><strong>创建型模式</strong>（对象怎么来）<br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</li>
<li><strong>结构型模式</strong>（对象和谁有关）<br>这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。</li>
<li><strong>行为型模式</strong>（对象与对象在干嘛）<br>这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。</li>
<li><strong>J2EE 模式</strong>（对象合起来要干嘛（表现层，文中表示层个人感觉用的不准确）java是面向对象的语言，所以要搞好对象，模式（套路）就是用来更加好的搞对象滴。）<br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</li>
</ul>
<h3 id="设计模式的优点"><a href="#设计模式的优点" class="headerlink" title="设计模式的优点"></a>设计模式的优点</h3><ul>
<li>提供了一种共享的设计词汇和概念，使开发人员能够更好地沟通和理解彼此的设计意图。</li>
<li>提供了经过验证的解决方案，可以提高软件的可维护性、可复用性和灵活性。</li>
<li>促进了代码的重用，避免了重复的设计和实现。</li>
<li>通过遵循设计模式，可以减少系统中的错误和问题，提高代码质量。</li>
</ul>
<h3 id="设计模式的基本原则"><a href="#设计模式的基本原则" class="headerlink" title="设计模式的基本原则"></a>设计模式的基本原则</h3><ul>
<li>单一职责原则（Single Responsibilities Principle）：一个类应该只负责一项职责。</li>
<li>开闭原则（Open Close Principle）：对扩展开放，对修改关闭。进行拓展的时候，不能去修改原有的代码，实现热插拔，提高扩展性。</li>
<li>里氏代换原则（Liskov Substitution Principle）：对开闭原则的补充。实现抽象的规范，实现子父类互相替换。</li>
<li>依赖倒转原则（Dependence Inversion Principle）：是开闭原则的基础。针对接口编程，实现开闭原则的基础。</li>
<li>接口隔离原则（Interface Segregation Principle）：降低耦合度，接口单独设计，互相隔离。</li>
<li>迪米特法则，又称最少知道原则（Demeter Principle）：功能模块尽量独立。</li>
<li>合成复用原则（Composite Reuse Principle）：尽量使用聚合，组合，而不是继承。</li>
</ul>
<h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h2><blockquote>
<p>对象怎么来</p>
</blockquote>
<p><strong>示例声明：</strong></p>
<ul>
<li><p>工厂模式（Factory Pattern）<br>加工工厂：给它“M4A1”，它给你产把警枪，给它“AK47”，你就端了把匪枪。CS里买枪的程序一定是用这个模式的。</p>
</li>
<li><p>抽象工厂模式（Abstract Factory Pattern）</p>
</li>
<li><p>建造者模式（Builder Pattern）<br>生产流水线：以前是手工业作坊式的人工单个单个的生产零件然后一步一步组装做，好比有了工业革命，现在都由生产流水线代替了。如要造丰田汽车，先制定汽车的构造如由车胎、方向盘、发动机组成。再以此构造标准生产丰田汽车的车胎、方向盘、发动机。然后进行组装。最后得到丰田汽车；</p>
</li>
<li><p>原型模式（Prototype Pattern）<br>印刷术的发明：以前只能临贴抄写费时费力，效率极低，有了印刷术，突突的；</p>
</li>
<li><p>单例模式（Singleton Pattern）<br>确保唯一：不是靠new的，是靠instance的，而且要instance地全世界就这么一个实例(这可怜的类，也配叫“类”)。 看SingleTon类代码。</p>
</li>
</ul>
<h2 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2. 结构型模式"></a>2. 结构型模式</h2><blockquote>
<p>对象和谁有关</p>
</blockquote>
<ul>
<li><p>适配器模式（Adapter Pattern）<br>翻译官：胡哥只会汉语，布什只会美语，翻译官既通汉又通美，Adapter了 ；</p>
</li>
<li><p>装饰器模式（Decorator Pattern）<br>装饰：名字可以标识一个人，为了表示对一个人的尊重，一般会称其为“尊敬的”，有了装饰，好看多了；</p>
</li>
<li><p>过滤器模式（Filter、Criteria Pattern）</p>
</li>
<li><p>桥接模式（Bridge Pattern）<br>白马非马：马之颜色有黑白，马之性别有公母。我们说”这是马”太抽象，说”这是黑色的公马”又太死板，只有将颜色与性别和马动态组合，”这是（黑色的或白色的）（公或母）马”才显得灵活而飘逸，如此bridge模式精髓得矣。</p>
</li>
<li><p>组合模式（Composite Pattern）<br>大家族：子又生孙，孙又生子，子子孙孙，无穷尽也，将众多纷杂的人口组织成一个按辈分排列的大家族即是此模式的实现；</p>
</li>
<li><p>外观模式（Facade Pattern）<br>求同存异：高中毕业需读初中和高中，博士也需读初中和高中，因此国家将初中和高中普及成九年制义务教育；</p>
</li>
<li><p>享元模式（Flyweight Pattern）<br>一劳永逸：认识三千汉字，可以应付日常读书与写字，可见头脑中存在这个汉字库的重要；</p>
</li>
<li><p>代理模式（Proxy Pattern）<br>垂帘听政：犹如清朝康熙年间的四大府臣，很多权利不在皇帝手里，必须通过辅佐大臣去办；</p>
</li>
</ul>
<h2 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3. 行为型模式"></a>3. 行为型模式</h2><blockquote>
<p>对象与对象在干嘛</p>
</blockquote>
<ul>
<li><p>责任链模式（Chain of Responsibility Pattern）<br>租房：以前为了找房到处打听，效率低且找不到好的房源。现在有了房屋中介，于是向房屋中介提出租房请求，中介提供一个合适的房源，满意则不再请求，不满意继续看房，直到满意为止；</p>
</li>
<li><p>命令模式（Command Pattern）<br>借刀杀人：以前是想杀谁就杀，但一段时间后领悟到，长此以往必将结仇太多，于是假手他人，挑拨他人之间的关系从而达到自己的目的；</p>
</li>
<li><p>解释器模式（Interpreter Pattern）<br>文言文注释：一段文言文，将它翻译成白话文；</p>
</li>
<li><p>迭代器模式（Iterator Pattern）<br>赶尽杀绝：一个一个的搜索，绝不放掉一个；</p>
</li>
<li><p>中介者模式（Mediator Pattern）<br>三角债：本来千头万绪的债务关系，忽出来一中介，包揽其一切，于是三角关系变成了独立的三方找第四方中介的关系；</p>
</li>
<li><p>备忘录模式（Memento Pattern）<br>有福同享：我有多少，你就有多少；</p>
</li>
<li><p>观察者模式（Observer Pattern）<br>看守者：一旦被看守者有什么异常情况，定会及时做出反应；</p>
</li>
<li><p>状态模式（State Pattern）<br>进出自由：如一扇门，能进能出，如果有很多人随时进进出出必定显得杂乱而安全，如今设一保安限制其进出，如此各人进出才显得规范；</p>
</li>
<li><p>空对象模式（Null Object Pattern）</p>
</li>
<li><p>策略模式（Strategy Pattern）<br>久病成良医：如人生病可以有各种症状，但经过长期摸索，就可以总结出感冒、肺病、肝炎等几种；</p>
</li>
<li><p>模板模式（Template Pattern）<br>理论不一定要实践：教练的学生会游泳就行了，至于教练会不会则无关紧要；</p>
</li>
<li><p>访问者模式（Visitor Pattern）<br>依法治罪：因张三杀人要被处死，李四偷窃要被罚款。由此势必制定处罚制度，故制定法律写明杀人、放火、偷窃等罪要受什么处罚，经通过后须变动要小。今后有人犯罪不管是谁，按共条例处罚即是，这就是访问者模式诞生的全过程。</p>
</li>
</ul>
<h2 id="4-J2EE模式"><a href="#4-J2EE模式" class="headerlink" title="4. J2EE模式"></a>4. J2EE模式</h2><blockquote>
<p>对象合起来要干嘛（表现层，文中表示层个人感觉用的不准确）java是面向对象的语言，所以要搞好对象，模式（套路）就是用来更加好的搞对象滴。</p>
</blockquote>
<h3 id="MVC-模式（MVC-Pattern）"><a href="#MVC-模式（MVC-Pattern）" class="headerlink" title="MVC 模式（MVC Pattern）"></a>MVC 模式（MVC Pattern）</h3><blockquote>
<p>Model-View-Controller（模型-视图-控制器） 模式。用于应用程序的分层开发。</p>
</blockquote>
<ul>
<li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<img src="/my_images/设计模式/mvc-1.png" style="zoom: 50%;" />



<p><strong>举例实现</strong></p>
<ul>
<li>我们将创建一个作为模型的 <strong>Student 对象</strong>。</li>
<li><strong>StudentView</strong> 是一个把学生详细信息输出到控制台的视图类。</li>
<li><strong>StudentController</strong> 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。</li>
<li><strong>MVCPatternDemo</strong>，我们的演示类使用 StudentController 来演示 MVC 模式的用法。</li>
</ul>
<p><img src="/my_images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvc-2.svg"></p>
<h3 id="业务代表模式（Business-Delegate-Pattern）"><a href="#业务代表模式（Business-Delegate-Pattern）" class="headerlink" title="业务代表模式（Business Delegate Pattern）"></a>业务代表模式（Business Delegate Pattern）</h3><h3 id="组合实体模式（Composite-Entity-Pattern）"><a href="#组合实体模式（Composite-Entity-Pattern）" class="headerlink" title="组合实体模式（Composite Entity Pattern）"></a>组合实体模式（Composite Entity Pattern）</h3><h3 id="数据访问对象模式（Data-Access-Object-Pattern）"><a href="#数据访问对象模式（Data-Access-Object-Pattern）" class="headerlink" title="数据访问对象模式（Data Access Object Pattern）"></a>数据访问对象模式（Data Access Object Pattern）</h3><h3 id="前端控制器模式（Front-Controller-Pattern）"><a href="#前端控制器模式（Front-Controller-Pattern）" class="headerlink" title="前端控制器模式（Front Controller Pattern）"></a>前端控制器模式（Front Controller Pattern）</h3><h3 id="拦截过滤器模式（Intercepting-Filter-Pattern）"><a href="#拦截过滤器模式（Intercepting-Filter-Pattern）" class="headerlink" title="拦截过滤器模式（Intercepting Filter Pattern）"></a>拦截过滤器模式（Intercepting Filter Pattern）</h3><h3 id="服务定位器模式（Service-Locator-Pattern）"><a href="#服务定位器模式（Service-Locator-Pattern）" class="headerlink" title="服务定位器模式（Service Locator Pattern）"></a>服务定位器模式（Service Locator Pattern）</h3><h3 id="传输对象模式（Transfer-Object-Pattern）"><a href="#传输对象模式（Transfer-Object-Pattern）" class="headerlink" title="传输对象模式（Transfer Object Pattern）"></a>传输对象模式（Transfer Object Pattern）</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">https://www.runoob.com/design-pattern/design-pattern-intro.html</a>	“参考链接1菜鸟教程”</p>
<p>[2]:<a href="https://zhuanlan.zhihu.com/p/570100908">https://zhuanlan.zhihu.com/p/570100908</a>	“参考链接2基本原则”</p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
