<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++基础之指针</title>
    <url>/2021/06/315ec67734e1.html</url>
    <content><![CDATA[<p>[toc]</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>这是在测试</title>
    <url>/2023/09/e5cb20f8607e.html</url>
    <content><![CDATA[<h1 id="test-my-blog"><a href="#test-my-blog" class="headerlink" title="test my blog"></a>test my blog</h1><p>test my blogtest my blog</p>
]]></content>
      <categories>
        <category>零零碎碎</category>
      </categories>
  </entry>
  <entry>
    <title>C++基础知识</title>
    <url>/2023/06/8ae987bd8514.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题部分"><a href="#问题部分" class="headerlink" title="问题部分"></a>问题部分</h2><h3 id="1-说说include头文件的顺序以及双引号””和尖括号的区别"><a href="#1-说说include头文件的顺序以及双引号””和尖括号的区别" class="headerlink" title="1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h3><blockquote>
<p><a href="#1">参考答案</a></p>
</blockquote>
<h3 id="2-导入C函数的关键字是什么，C-编译时和C有什么不同？"><a href="#2-导入C函数的关键字是什么，C-编译时和C有什么不同？" class="headerlink" title="2.导入C函数的关键字是什么，C++编译时和C有什么不同？"></a>2.导入C函数的关键字是什么，C++编译时和C有什么不同？</h3><blockquote>
<p><a href="#2">参考答案</a></p>
</blockquote>
<h3 id="3-C-中前置操作性能一定优于后置操作吗？"><a href="#3-C-中前置操作性能一定优于后置操作吗？" class="headerlink" title="3.C++中前置操作性能一定优于后置操作吗？"></a>3.C++中前置操作性能一定优于后置操作吗？</h3><blockquote>
<p><a href="#3">参考答案</a></p>
</blockquote>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><blockquote>
<p><a href="#4">参考答案</a></p>
</blockquote>
<h2 id="答案部分，仅供参考"><a href="#答案部分，仅供参考" class="headerlink" title="答案部分，仅供参考"></a>答案部分，仅供参考</h2><p id='1'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案1-说说include头文件的顺序以及双引号””和尖括号的区别"><a href="#答案1-说说include头文件的顺序以及双引号””和尖括号的区别" class="headerlink" title="答案1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>答案1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h3><p><strong>区别</strong>：</p>
<ul>
<li>（1）尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。</li>
<li>（2）编译器预处理阶段查找头文件的路径不一样。</li>
</ul>
<p><strong>查找路径</strong>：</p>
<ul>
<li>（1）使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量。</li>
<li>（2）使用双引号””的头文件的查找路径：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。</li>
</ul>
<p id='2'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案2-导入C函数的关键字是什么，C-编译时和C有什么不同？"><a href="#答案2-导入C函数的关键字是什么，C-编译时和C有什么不同？" class="headerlink" title="答案2.导入C函数的关键字是什么，C++编译时和C有什么不同？"></a>答案2.导入C函数的关键字是什么，C++编译时和C有什么不同？</h3><ul>
<li><strong>关键字</strong>：在C++中，导入C函数的关键字是<strong>extern</strong>，表达形式为**extern “C”**， extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</li>
<li><strong>编译区别</strong>：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时<strong>不会</strong>带上函数的<strong>参数类型</strong>，一般只包括<strong>函数名</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extern示例</span></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span><span class="comment">//string.h里边包含了要调用的C函数的声明</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span></span><br></pre></td></tr></table></figure>


<p id='3'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案3-C-中前置操作性能一定优于后置操作吗？"><a href="#答案3-C-中前置操作性能一定优于后置操作吗？" class="headerlink" title="答案3.C++中前置操作性能一定优于后置操作吗？"></a>答案3.C++中前置操作性能一定优于后置操作吗？</h3><blockquote>
<p><a href="https://m.elecfans.com/article/1929824.html">详细参考链接</a></p>
</blockquote>
<p><strong>结论</strong>：</p>
<ul>
<li>原理来说：前置操作遵循的规则是change-then-use，而后置操作遵循的规则是use-then-change。所以，前置操作就地修改对象；后置操作的时候，会使得编译器在实现该操作的时候，先把之前的值进行拷贝备份，然后对值进行更改操作，最后返回之前备份的值。因此，后置操作会产生临时变量，而前置操作不会。</li>
<li>对于内置类型，前置操作和后置操作二者在性能上无差异，这是因为编译器会对其进行优化。</li>
<li>对于自定义类型，前置操作的性能远优于后置操作。除非必须使用i++以满足编码场景，否则，在任何情况下都建议使用++i这种前置操作。</li>
<li>很多人都会认为前置操作性能优于后置操作，这是错误的观点，在此进行下纠正，准确的说法应该是前置操作不会比后置操作性能差。</li>
</ul>
<p id='4'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案4"><a href="#答案4" class="headerlink" title="答案4"></a>答案4</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语法之priority_queue自定义大小根堆</title>
    <url>/2023/10/af4bec111749.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;priority_queue&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="基础调用API"><a href="#基础调用API" class="headerlink" title="基础调用API"></a>基础调用API</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; q1;<span class="comment">//默认大根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; q2;<span class="comment">//完全体的大根堆，和上述一致</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q3;<span class="comment">//小根堆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="进阶思考，自定义数据类型"><a href="#进阶思考，自定义数据类型" class="headerlink" title="进阶思考，自定义数据类型"></a>进阶思考，自定义数据类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; <span class="comment">//是&gt; 而不是&lt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, cmp1&gt; q4;<span class="comment">//自定义小根堆</span></span><br><span class="line">    priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, cmp2&gt; q5;<span class="comment">//自定义大根堆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语法之unordered_map的4种遍历方式</title>
    <url>/2023/11/46b9beb2691f.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="方式一：值传递遍历"><a href="#方式一：值传递遍历" class="headerlink" title="方式一：值传递遍历"></a>方式一：值传递遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="方式二：引用传递遍历"><a href="#方式二：引用传递遍历" class="headerlink" title="方式二：引用传递遍历"></a>方式二：引用传递遍历</h2><blockquote>
<p>注意：要加const</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*const加里面也是可以的*/</span></span><br><span class="line"><span class="keyword">for</span>(pair&lt;<span class="type">const</span> <span class="type">int</span>, <span class="type">int</span>&gt;&amp; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="方式三：使用迭代器遍历"><a href="#方式三：使用迭代器遍历" class="headerlink" title="方式三：使用迭代器遍历"></a>方式三：使用迭代器遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式四：结构化绑定-c-17特性"><a href="#方式四：结构化绑定-c-17特性" class="headerlink" title="方式四：结构化绑定(c++17特性)"></a>方式四：结构化绑定(c++17特性)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*值传递*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [k, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*引用传递*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [k, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其中，如果只想使用键，值可以用_代替*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[k, _]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*同理，如果指向只用值，键可以用_代替*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础之格式化输出</title>
    <url>/2023/11/dcbca6ff400e.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="使用printf-函数进行格式化输出："><a href="#使用printf-函数进行格式化输出：" class="headerlink" title="使用printf()函数进行格式化输出："></a>使用printf()函数进行格式化输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> price = <span class="number">19.99</span>;</span><br><span class="line"><span class="type">int</span> quantity = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total price: $%.2f\n&quot;</span>, price * quantity);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Quantity: %04d\n&quot;</span>, quantity);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">%.2f用于格式化输出小数点后两位；%04d用于设置输出占据宽度为4，并在前面填充零。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用&lt;&lt;运算符和格式控制符进行输出："></a>使用&lt;&lt;运算符和格式控制符进行输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Pi: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">std::fixed和std::setprecision(2)用于固定小数位并设置精度为两位小数。</span></span><br><span class="line"><span class="comment">std::setw(5)和std::setfill(&#x27;0&#x27;)用于设置输出宽度为5，并在前面填充零。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="使用字符串流（stringstream）进行格式化输出："><a href="#使用字符串流（stringstream）进行格式化输出：" class="headerlink" title="使用字符串流（stringstream）进行格式化输出："></a>使用字符串流（stringstream）进行格式化输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> weight = <span class="number">65.5</span>;</span><br><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; weight &lt;&lt; <span class="string">&quot;kg\n&quot;</span>;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将要输出的内容逐个写入字符串流中，然后通过ss.str()将字符串流的内容转换为字符串进行输出。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>有限状态自动机</title>
    <url>/2023/11/261d7fd3675f.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="定义——有限自动机"><a href="#定义——有限自动机" class="headerlink" title="定义——有限自动机"></a>定义——有限自动机</h2><blockquote>
<p>有限状态机（Finite-state machine, FSM），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。<br>有限状态机可以将复杂的逻辑简化为有限个稳定状态，在稳定状态中判断事件。其中有限不是指有限次处理，而是有限个稳定状态。</p>
</blockquote>
<p>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p>
<p>在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。</p>
<p><strong>有限状态机在日常中也随处可见:</strong></p>
<ul>
<li>红绿灯控制系统：主干道、支干道的黄灯、红灯、绿灯交替显示；</li>
<li>地铁入口的门禁闸机：只有被闸机接受的刷卡行为，闸机才会将关闭状态变为开启状态；</li>
<li>自动售卖机，只有投入合适的硬币，售卖机才会吐出相应的产品；</li>
<li>密码箱，只有输入正确的密码序列，密码箱才会变为开启状态。</li>
</ul>
<p><strong>状态机的要素</strong><br>状态机的本质是有向图：包括节点和路径。</p>
<ul>
<li>节点表示状态，路径表示状态迁移。</li>
</ul>
<p>大多状态机在路径上会增加一些附加信息来表明状态迁移的细节：条件 &#x2F; 动作。前者表示引起状态迁移的事件，后者表示与该状态迁移相关联的动作。</p>
<p>比如：地铁入口的门禁闸机，在用户刷卡后，如果接受，则闸机会打开闸门。这里的“用户刷卡”就是“条件”，“闸机会打开闸门”就是动作。</p>
<p>状态机可归纳为<strong>6个要素</strong>，即<strong>活跃状态（现态）</strong>、<strong>输入事件（条件）</strong>、<strong>输出事件（动作）</strong>、<strong>次态</strong>、<strong>初始</strong>和<strong>终止状态</strong>。“活跃状态”和“条件”是因，“动作”和“次态”是果。详解如下：</p>
<ul>
<li>活跃状态，也叫现态：是指当前所处的状态。任何时候，只有一个状态能够成为活跃状态；</li>
<li>输入事件：又称为“条件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移；</li>
<li>输出事件：又称为“动作”，条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态；</li>
<li>次态：条件满足后要迁往的新状态。“次态”是相对于“活跃状态”而言的，“次态”一旦被激活，就转变成新的“活跃状态”了；</li>
<li>初始状态：即没有状态转入的状态。只有一个初始状态</li>
<li>终止状态：即没有状态转出的状态。只有一个终止状态</li>
</ul>
<p>可以用 <strong>迁移状态表</strong> 表示整个过程，如下表：</p>
<table>
<thead>
<tr>
<th align="center">活跃状态 \ 输入&#x2F;输出</th>
<th align="center">触发条件1&#x2F;[执行动作1]</th>
<th align="center">触发条件2&#x2F;[执行动作2]</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">初始状态</td>
<td align="center">中间状态1</td>
<td align="center">中间状态2</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态1</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态2</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态…</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
</tbody></table>
<p><strong>有限状态机分类</strong><br>主要有 <strong>接收器（acceptors）</strong> 和 <strong>转换器（transducers）</strong> 两种。转换器（transducers）依据状态和输入的关系，又分为两种：<strong>moore 状态机</strong>和 <strong>mealy 状态机</strong>。</p>
<ul>
<li><p><strong>接收器（acceptors）</strong><br>接收器是指产生一个二值的输出，指示接收的输入是否能被接受。比如地铁入口的门禁闸机，在用户刷卡后决定是否打开闸门放行</p>
</li>
<li><p><strong>transducers(转换器)</strong><br>转换器（moore 状态机和 mealy 状态机）一般输出会受输入序列顺序影响，mealy 状态机还会受当前状态影响。我们一般看到的状态机大部分是 mealy 状态机。</p>
</li>
</ul>
<h2 id="力扣8-字符串转换整数-atoi-官方代码参考"><a href="#力扣8-字符串转换整数-atoi-官方代码参考" class="headerlink" title="力扣8.字符串转换整数 (atoi)官方代码参考"></a>力扣8.字符串转换整数 (atoi)官方代码参考</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span> &#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="type">long</span> <span class="type">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>)</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str)</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/651128045">编程——有限自动机 - leancode的文章 - 知乎</a><br><a href="https://leetcode.cn/problems/string-to-integer-atoi/solutions/183164/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/">leetcode8.字符串转换整数 (atoi)</a></p>
]]></content>
      <categories>
        <category>编程的额外知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
</search>
