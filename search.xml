<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++基础之指针</title>
    <url>/2021/06/315ec67734e1.html</url>
    <content><![CDATA[<p>[toc]</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>这是在测试</title>
    <url>/2023/09/e5cb20f8607e.html</url>
    <content><![CDATA[<h1 id="test-my-blog"><a href="#test-my-blog" class="headerlink" title="test my blog"></a>test my blog</h1><p>test my blogtest my blog</p>
]]></content>
      <categories>
        <category>零零碎碎</category>
      </categories>
  </entry>
  <entry>
    <title>C++基础知识</title>
    <url>/2023/06/8ae987bd8514.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题部分"><a href="#问题部分" class="headerlink" title="问题部分"></a>问题部分</h2><h3 id="1-说说include头文件的顺序以及双引号””和尖括号的区别"><a href="#1-说说include头文件的顺序以及双引号””和尖括号的区别" class="headerlink" title="1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h3><blockquote>
<p><a href="#1">参考答案</a></p>
</blockquote>
<h3 id="2-导入C函数的关键字是什么，C-编译时和C有什么不同？"><a href="#2-导入C函数的关键字是什么，C-编译时和C有什么不同？" class="headerlink" title="2.导入C函数的关键字是什么，C++编译时和C有什么不同？"></a>2.导入C函数的关键字是什么，C++编译时和C有什么不同？</h3><blockquote>
<p><a href="#2">参考答案</a></p>
</blockquote>
<h3 id="3-C-中前置操作性能一定优于后置操作吗？"><a href="#3-C-中前置操作性能一定优于后置操作吗？" class="headerlink" title="3.C++中前置操作性能一定优于后置操作吗？"></a>3.C++中前置操作性能一定优于后置操作吗？</h3><blockquote>
<p><a href="#3">参考答案</a></p>
</blockquote>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><blockquote>
<p><a href="#4">参考答案</a></p>
</blockquote>
<h2 id="答案部分，仅供参考"><a href="#答案部分，仅供参考" class="headerlink" title="答案部分，仅供参考"></a>答案部分，仅供参考</h2><p id='1'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案1-说说include头文件的顺序以及双引号””和尖括号的区别"><a href="#答案1-说说include头文件的顺序以及双引号””和尖括号的区别" class="headerlink" title="答案1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>答案1.说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h3><p><strong>区别</strong>：</p>
<ul>
<li>（1）尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。</li>
<li>（2）编译器预处理阶段查找头文件的路径不一样。</li>
</ul>
<p><strong>查找路径</strong>：</p>
<ul>
<li>（1）使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量。</li>
<li>（2）使用双引号””的头文件的查找路径：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。</li>
</ul>
<p id='2'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案2-导入C函数的关键字是什么，C-编译时和C有什么不同？"><a href="#答案2-导入C函数的关键字是什么，C-编译时和C有什么不同？" class="headerlink" title="答案2.导入C函数的关键字是什么，C++编译时和C有什么不同？"></a>答案2.导入C函数的关键字是什么，C++编译时和C有什么不同？</h3><ul>
<li><strong>关键字</strong>：在C++中，导入C函数的关键字是<strong>extern</strong>，表达形式为**extern “C”**， extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</li>
<li><strong>编译区别</strong>：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时<strong>不会</strong>带上函数的<strong>参数类型</strong>，一般只包括<strong>函数名</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extern示例</span></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span><span class="comment">//string.h里边包含了要调用的C函数的声明</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span></span><br></pre></td></tr></table></figure>


<p id='3'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案3-C-中前置操作性能一定优于后置操作吗？"><a href="#答案3-C-中前置操作性能一定优于后置操作吗？" class="headerlink" title="答案3.C++中前置操作性能一定优于后置操作吗？"></a>答案3.C++中前置操作性能一定优于后置操作吗？</h3><blockquote>
<p><a href="https://m.elecfans.com/article/1929824.html">详细参考链接</a></p>
</blockquote>
<p><strong>结论</strong>：</p>
<ul>
<li>原理来说：前置操作遵循的规则是change-then-use，而后置操作遵循的规则是use-then-change。所以，前置操作就地修改对象；后置操作的时候，会使得编译器在实现该操作的时候，先把之前的值进行拷贝备份，然后对值进行更改操作，最后返回之前备份的值。因此，后置操作会产生临时变量，而前置操作不会。</li>
<li>对于内置类型，前置操作和后置操作二者在性能上无差异，这是因为编译器会对其进行优化。</li>
<li>对于自定义类型，前置操作的性能远优于后置操作。除非必须使用i++以满足编码场景，否则，在任何情况下都建议使用++i这种前置操作。</li>
<li>很多人都会认为前置操作性能优于后置操作，这是错误的观点，在此进行下纠正，准确的说法应该是前置操作不会比后置操作性能差。</li>
</ul>
<p id='4'></p> <!-- 设定锚点跳转//这是可以多段的注释 -->

<h3 id="答案4"><a href="#答案4" class="headerlink" title="答案4"></a>答案4</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语法之priority_queue自定义大小根堆</title>
    <url>/2023/10/af4bec111749.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;priority_queue&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="基础调用API"><a href="#基础调用API" class="headerlink" title="基础调用API"></a>基础调用API</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; q1;<span class="comment">//默认大根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; q2;<span class="comment">//完全体的大根堆，和上述一致</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q3;<span class="comment">//小根堆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="进阶思考，自定义数据类型"><a href="#进阶思考，自定义数据类型" class="headerlink" title="进阶思考，自定义数据类型"></a>进阶思考，自定义数据类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; <span class="comment">//是&gt; 而不是&lt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, cmp1&gt; q4;<span class="comment">//自定义小根堆</span></span><br><span class="line">    priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, cmp2&gt; q5;<span class="comment">//自定义大根堆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语法之unordered_map的4种遍历方式</title>
    <url>/2023/11/46b9beb2691f.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="方式一：值传递遍历"><a href="#方式一：值传递遍历" class="headerlink" title="方式一：值传递遍历"></a>方式一：值传递遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="方式二：引用传递遍历"><a href="#方式二：引用传递遍历" class="headerlink" title="方式二：引用传递遍历"></a>方式二：引用传递遍历</h2><blockquote>
<p>注意：要加const</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*const加里面也是可以的*/</span></span><br><span class="line"><span class="keyword">for</span>(pair&lt;<span class="type">const</span> <span class="type">int</span>, <span class="type">int</span>&gt;&amp; kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;kv: map)&#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="方式三：使用迭代器遍历"><a href="#方式三：使用迭代器遍历" class="headerlink" title="方式三：使用迭代器遍历"></a>方式三：使用迭代器遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用auto*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式四：结构化绑定-c-17特性"><a href="#方式四：结构化绑定-c-17特性" class="headerlink" title="方式四：结构化绑定(c++17特性)"></a>方式四：结构化绑定(c++17特性)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*值传递*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [k, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*引用传递*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [k, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*其中，如果只想使用键，值可以用_代替*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[k, _]: map)&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*同理，如果指向只用值，键可以用_代替*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_, v]: map)&#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础之格式化输出</title>
    <url>/2023/11/dcbca6ff400e.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="使用printf-函数进行格式化输出："><a href="#使用printf-函数进行格式化输出：" class="headerlink" title="使用printf()函数进行格式化输出："></a>使用printf()函数进行格式化输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> price = <span class="number">19.99</span>;</span><br><span class="line"><span class="type">int</span> quantity = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total price: $%.2f\n&quot;</span>, price * quantity);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Quantity: %04d\n&quot;</span>, quantity);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">%.2f用于格式化输出小数点后两位；%04d用于设置输出占据宽度为4，并在前面填充零。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用&lt;&lt;运算符和格式控制符进行输出："></a>使用&lt;&lt;运算符和格式控制符进行输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Pi: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">std::fixed和std::setprecision(2)用于固定小数位并设置精度为两位小数。</span></span><br><span class="line"><span class="comment">std::setw(5)和std::setfill(&#x27;0&#x27;)用于设置输出宽度为5，并在前面填充零。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="使用字符串流（stringstream）进行格式化输出："><a href="#使用字符串流（stringstream）进行格式化输出：" class="headerlink" title="使用字符串流（stringstream）进行格式化输出："></a>使用字符串流（stringstream）进行格式化输出：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> weight = <span class="number">65.5</span>;</span><br><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Weight: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; weight &lt;&lt; <span class="string">&quot;kg\n&quot;</span>;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将要输出的内容逐个写入字符串流中，然后通过ss.str()将字符串流的内容转换为字符串进行输出。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>有限状态自动机</title>
    <url>/2023/11/261d7fd3675f.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="定义——有限自动机"><a href="#定义——有限自动机" class="headerlink" title="定义——有限自动机"></a>定义——有限自动机</h2><blockquote>
<p>有限状态机（Finite-state machine, FSM），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。<br>有限状态机可以将复杂的逻辑简化为有限个稳定状态，在稳定状态中判断事件。其中有限不是指有限次处理，而是有限个稳定状态。</p>
</blockquote>
<p>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p>
<p>在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。</p>
<p><strong>有限状态机在日常中也随处可见:</strong></p>
<ul>
<li>红绿灯控制系统：主干道、支干道的黄灯、红灯、绿灯交替显示；</li>
<li>地铁入口的门禁闸机：只有被闸机接受的刷卡行为，闸机才会将关闭状态变为开启状态；</li>
<li>自动售卖机，只有投入合适的硬币，售卖机才会吐出相应的产品；</li>
<li>密码箱，只有输入正确的密码序列，密码箱才会变为开启状态。</li>
</ul>
<p><strong>状态机的要素</strong><br>状态机的本质是有向图：包括节点和路径。</p>
<ul>
<li>节点表示状态，路径表示状态迁移。</li>
</ul>
<p>大多状态机在路径上会增加一些附加信息来表明状态迁移的细节：条件 &#x2F; 动作。前者表示引起状态迁移的事件，后者表示与该状态迁移相关联的动作。</p>
<p>比如：地铁入口的门禁闸机，在用户刷卡后，如果接受，则闸机会打开闸门。这里的“用户刷卡”就是“条件”，“闸机会打开闸门”就是动作。</p>
<p>状态机可归纳为<strong>6个要素</strong>，即<strong>活跃状态（现态）</strong>、<strong>输入事件（条件）</strong>、<strong>输出事件（动作）</strong>、<strong>次态</strong>、<strong>初始</strong>和<strong>终止状态</strong>。“活跃状态”和“条件”是因，“动作”和“次态”是果。详解如下：</p>
<ul>
<li>活跃状态，也叫现态：是指当前所处的状态。任何时候，只有一个状态能够成为活跃状态；</li>
<li>输入事件：又称为“条件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移；</li>
<li>输出事件：又称为“动作”，条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态；</li>
<li>次态：条件满足后要迁往的新状态。“次态”是相对于“活跃状态”而言的，“次态”一旦被激活，就转变成新的“活跃状态”了；</li>
<li>初始状态：即没有状态转入的状态。只有一个初始状态</li>
<li>终止状态：即没有状态转出的状态。只有一个终止状态</li>
</ul>
<p>可以用 <strong>迁移状态表</strong> 表示整个过程，如下表：</p>
<table>
<thead>
<tr>
<th align="center">活跃状态 \ 输入&#x2F;输出</th>
<th align="center">触发条件1&#x2F;[执行动作1]</th>
<th align="center">触发条件2&#x2F;[执行动作2]</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">初始状态</td>
<td align="center">中间状态1</td>
<td align="center">中间状态2</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态1</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态2</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
<tr>
<td align="center">中间状态…</td>
<td align="center">中间状态x</td>
<td align="center">中间状态x</td>
<td align="center">中间状态…</td>
</tr>
</tbody></table>
<p><strong>有限状态机分类</strong><br>主要有 <strong>接收器（acceptors）</strong> 和 <strong>转换器（transducers）</strong> 两种。转换器（transducers）依据状态和输入的关系，又分为两种：<strong>moore 状态机</strong>和 <strong>mealy 状态机</strong>。</p>
<ul>
<li><p><strong>接收器（acceptors）</strong><br>接收器是指产生一个二值的输出，指示接收的输入是否能被接受。比如地铁入口的门禁闸机，在用户刷卡后决定是否打开闸门放行</p>
</li>
<li><p><strong>transducers(转换器)</strong><br>转换器（moore 状态机和 mealy 状态机）一般输出会受输入序列顺序影响，mealy 状态机还会受当前状态影响。我们一般看到的状态机大部分是 mealy 状态机。</p>
</li>
</ul>
<h2 id="力扣8-字符串转换整数-atoi-官方代码参考"><a href="#力扣8-字符串转换整数-atoi-官方代码参考" class="headerlink" title="力扣8.字符串转换整数 (atoi)官方代码参考"></a>力扣8.字符串转换整数 (atoi)官方代码参考</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span> &#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="type">long</span> <span class="type">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>)</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str)</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/651128045">编程——有限自动机 - leancode的文章 - 知乎</a><br><a href="https://leetcode.cn/problems/string-to-integer-atoi/solutions/183164/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/">leetcode8.字符串转换整数 (atoi)</a></p>
]]></content>
      <categories>
        <category>编程的额外知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2023/11/91fba8963d27.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="使用的工具："><a href="#使用的工具：" class="headerlink" title="使用的工具："></a>使用的工具：</h2><p><a href="https://typoraio.cn/">typora官网</a></p>
<p><a href="https://support.typoraio.cn/zh/Markdown-Reference/">typora官方学习markdown手册</a></p>
<p><a href="https://www.cnblogs.com/KoiC/p/17073950.html">仅供学习参考使用的免费typora</a></p>
<h2 id="常用typora快捷键："><a href="#常用typora快捷键：" class="headerlink" title="常用typora快捷键："></a>常用typora快捷键：</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CTRL+K</td>
<td>插入超链接</td>
</tr>
<tr>
<td>CTRL+T</td>
<td>插入表格</td>
</tr>
<tr>
<td>CTRL+Enter</td>
<td>表格里下方插入一行</td>
</tr>
<tr>
<td>CTRL+B</td>
<td>字体加粗</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>CTRL+Shift+[</td>
<td>有序列表</td>
</tr>
<tr>
<td>CTRL+Shift+]</td>
<td>无序列表</td>
</tr>
<tr>
<td>CTRL+Shift+K</td>
<td>代码块</td>
</tr>
<tr>
<td>CTRL+Shift+M</td>
<td>公式块（理解为：math）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="后续进行补充"><a href="#后续进行补充" class="headerlink" title="后续进行补充"></a>后续进行补充</h2><p>暂时完结</p>
]]></content>
      <categories>
        <category>工具相关</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一道有意思的算法题</title>
    <url>/2023/11/ffae31d2f853.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="给你一个从0开始的递增数组，将其随机打乱成另一个数组并返回。-字节"><a href="#给你一个从0开始的递增数组，将其随机打乱成另一个数组并返回。-字节" class="headerlink" title="给你一个从0开始的递增数组，将其随机打乱成另一个数组并返回。#字节#"></a>给你一个从0开始的递增数组，将其随机打乱成另一个数组并返回。#字节#</h2><blockquote>
<ol>
<li><p>要求使用O(1)空间内解决该问题</p>
</li>
<li><p>解决交换的次数越多随机数随到已经交换的下标的可能性越大的问题</p>
<p>该算法已有标准实现，可以自己看看</p>
</li>
</ol>
</blockquote>
<p>单纯从题目不加限制条件的角度来做，可以想到暴力法。标准实现还得看洗牌算法。</p>
<ol>
<li><strong>暴力法</strong>:申请另一个数组</li>
<li><strong>Fisher-Yates 洗牌算法</strong>：</li>
</ol>
<blockquote>
<p>我们可以在移除 <code>waiting</code> 的第 <code>k</code>个元素时，将第 <code>k</code>个元素与数组的最后 <code>1</code>个元素交换，然后移除交换后数组的最后 <code>1</code>个元素，这样我们只需要 <code>O(1)</code> 的时间复杂度即可完成移除第 <code>k</code> 个元素的操作。此时，被移除的交换后数组的最后 <code>1</code> 个元素即为我们根据随机下标获取的元素。</p>
<p>在此基础上，我们也可以不移除最后 <code>1</code> 个元素，而直接将其作为乱序后的结果，并更新待乱序数组的长度，从而实现数组的原地乱序。因为我们不再需要从数组中移除元素，所以也可以将第 <code>k</code> 个元素与第 <code>1</code> 个元素交换。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码同下</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Knuth 洗牌算法</strong>：</li>
</ol>
<blockquote>
<p>在 <code>O(n)</code> 复杂度内等概率返回某个方案。</p>
<p>具体的，我们从前往后尝试填充 <code>[0,n−1]</code> 该填入什么数时，通过随机当前下标与（剩余的）哪个下标进行值交换来实现。</p>
<p>对于下标 <code>x</code> 而言，我们从 <code>[x,n−1]</code> 中随机出一个位置与 <code>x</code> 进行值交换，当所有位置都进行这样的处理后，我们便得到了一个公平的洗牌方案。</p>
<p>这样能确保每个元素在每个位置的概率都是<code>1/n</code>。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">this</span>-&gt;original.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">copy</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), original.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">copy</span>(original.<span class="built_in">begin</span>(), original.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="built_in">rand</span>() % (nums.<span class="built_in">size</span>() - i);</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; original;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>解答参考链接：</p>
<p>[1]:<a href="https://blog.csdn.net/cy973071263/article/details/128818181">https://blog.csdn.net/cy973071263/article/details/128818181</a>	“参考链接1”<br>[2]:<a href="https://blog.csdn.net/defaultbyzt/article/details/128628119">https://blog.csdn.net/defaultbyzt/article/details/128628119</a>	“参考链接2”<br>[3]:<a href="https://www.bilibili.com/read/cv26024350/">https://www.bilibili.com/read/cv26024350/</a>	“参考链接3”<br>[4]:<a href="https://leetcode.cn/problems/shuffle-an-array/">https://leetcode.cn/problems/shuffle-an-array/</a>	“参考链接4”</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决TCP粘包问题</title>
    <url>/2023/11/8c2faec0a14b.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="TCP粘包问题"><a href="#TCP粘包问题" class="headerlink" title="TCP粘包问题"></a>TCP粘包问题</h2><ul>
<li>TCP数据粘包是指发送方连续发送多个数据包时，接收方在接收时会将多个数据包粘成一个大的数据包，造成数据处理上的困难。</li>
<li>首先回忆一下，TCP的三大特点：面向连接、可靠的、基于字节流的。</li>
<li>显然，问题出在<code>TCP是基于字节流的</code>，所以并不会明确TCP包的边界。而UDP是基于包的，所以不会出现这个问题。</li>
</ul>
<h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><blockquote>
<p>总的原则：既然没有边界，那么加上边界识别的机制那就完活了。</p>
</blockquote>
<ol>
<li><p>设置消息边界：在消息的末尾添加特殊字符或者标志符号，在接收方收到消息时根据特殊字符或标志符号来分隔消息。</p>
</li>
<li><p>消息长度：在消息的开头添加消息长度信息，在接收方接收到消息时先读取消息长度，再读取对应长度的消息内容。</p>
</li>
<li><p>延迟发送：发送方在发送数据时，可以采用延迟发送的方式，即等待一段时间再发送，以此避免多个数据包同时发送造成粘包。</p>
</li>
<li><p>使用固定长度的数据包：发送方发送固定长度的数据包，接收方按照固定长度来接收数据包，以此避免粘包问题。 </p>
<p>举例：在Qt中，可以通过设置socket的读取缓存区大小、设置消息边界符号、消息长度信息等方式来防止TCP数据粘包。例如，可以使用以下代码设置消息边界符号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QTcpSocket *socket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">socket-&gt;<span class="built_in">setReadBufferSize</span>(<span class="number">1024</span>); <span class="comment">//设置读取缓存区大小为1024字节</span></span><br><span class="line">socket-&gt;<span class="built_in">write</span>(<span class="string">&quot;message1\n&quot;</span>); <span class="comment">//发送消息1</span></span><br><span class="line">socket-&gt;<span class="built_in">write</span>(<span class="string">&quot;message2\n&quot;</span>); <span class="comment">//发送消息2</span></span><br></pre></td></tr></table></figure>

<p>在接收方，可以使用以下代码来接收数据并根据消息边界符号分隔消息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (socket-&gt;<span class="built_in">bytesAvailable</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    QByteArray data = socket-&gt;<span class="built_in">readLine</span>(); <span class="comment">//读取一行数据</span></span><br><span class="line">    QString message = <span class="built_in">QString</span>(data).<span class="built_in">trimmed</span>(); <span class="comment">//去除换行符</span></span><br><span class="line">    <span class="comment">//处理接收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://blog.csdn.net/future_ai/article/details/130192182">https://blog.csdn.net/future_ai/article/details/130192182</a>	“参考链接1”</p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句相关问题</title>
    <url>/2023/11/f290346388e4.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="查询成绩表中每名学生成绩最高的课程和最大分数以及这个学生的名字"><a href="#查询成绩表中每名学生成绩最高的课程和最大分数以及这个学生的名字" class="headerlink" title="查询成绩表中每名学生成绩最高的课程和最大分数以及这个学生的名字"></a>查询成绩表中每名学生成绩最高的课程和最大分数以及这个学生的名字</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 给定成绩表t，表结构字段为(name, subject, score)</span><br><span class="line"></span><br><span class="line"># 使用子<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> name, <span class="built_in">max</span>(score) m <span class="keyword">from</span> t <span class="keyword">GROUP</span> <span class="keyword">BY</span> name) b, t</span><br><span class="line"><span class="keyword">where</span> t.name<span class="operator">=</span>b.name <span class="keyword">and</span> t.score<span class="operator">=</span>b.m</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>[1]:<a href="https://blog.csdn.net/zb199738/article/details/102767660">https://blog.csdn.net/zb199738/article/details/102767660</a>	“参考链接”</p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度消失、梯度爆炸怎么解决</title>
    <url>/2023/11/20b3b53ad2ba.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><blockquote>
<p>梯度消失与梯度爆炸其实是一种情况，看参考链接的文章就知道了。</p>
</blockquote>
<p>两种情况下梯度消失经常出现，一是在<strong>深层网络</strong>中，二是采用了<strong>不合适的损失函数</strong>，比如sigmoid。梯度爆炸一般出现在深层网络和权值初始化值太大的情况下。</p>
<h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><ol>
<li><p>预训练加微调。</p>
<p>此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。此方法来自Hinton在2006年发表的一篇论文，Hinton为了解决梯度的问题，提出采取无监督逐层训练方法，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。</p>
</li>
<li><p>梯度剪切、权重正则（针对梯度爆炸）。</p>
<p><strong>梯度剪切</strong>这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</p>
<p><strong>权重正则化</strong>（weithts regularization）比较常见的是l1正则，和l2正则，在各个深度框架中都有相应的API可以使用正则化。</p>
</li>
<li><p>使用不同的激活函数。</p>
<p>relu、leakrelu、elu等激活函数。</p>
</li>
<li><p>使用batchnorm。</p>
<p>Batchnorm本质上是解决反向传播过程中的梯度问题。batchnorm全名是batch normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。</p>
</li>
<li><p>使用残差结构。</p>
<p>事实上，就是残差网络的出现导致了image net比赛的终结，自从残差提出后，几乎所有的深度网络都离不开残差的身影，相比较之前的几层，几十层的深度网络，在残差网络面前都不值一提，残差可以很轻松的构建几百层，一千多层的网络而不用担心梯度消失过快的问题，原因就在于残差的捷径（shortcut）部分</p>
</li>
<li><p>使用LSTM网络。</p>
<p>LSTM全称是<strong>长短期记忆网络</strong>（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)。LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“，因此，经常用于生成文本中。目前也有基于CNN的LSTM，之后可以尝试一下。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://zhuanlan.zhihu.com/p/622605118?utm_id=0">https://zhuanlan.zhihu.com/p/622605118?utm_id=0</a>	“参考链接1”</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>过拟合和欠拟合怎么解决</title>
    <url>/2023/11/c1a54a404412.html</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><blockquote>
<p>过拟合和欠拟合是机器学习中常见的问题。</p>
</blockquote>
<ul>
<li><strong>过拟合</strong>指的是模型过于复杂，在训练数据上表现良好，但是在新数据上表现却很差。</li>
<li><strong>欠拟合</strong>指的是模型在训练集、验证集和测试集上均表现不佳的情况。</li>
</ul>
<h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><blockquote>
<p>过拟合和欠拟合的解决办法较为相对，反面基本可以解决另一个问题。下面谈谈针对过拟合。</p>
</blockquote>
<ol>
<li><p>增加数据量。</p>
<p>当数据量较少时，模型容易过拟合。因此，增加数据量是解决过拟合问题的重要方法之一。如果数据集无法扩充，可以通过数据增强的方式来达到类似的效果。</p>
</li>
<li><p>简化模型结构。</p>
<p>过于复杂的模型容易导致过拟合。因此，可以通过简化模型结构的方式来解决过拟合问题。例如，减少深度学习模型的层数、减少神经元数量等。此外，也可以通过增加正则化项来限制模型的复杂度。</p>
</li>
<li><p>采用正则化方法。</p>
<p>正则化是一种常用的防止过拟合的方法。它通过在损失函数中加入正则化项，对模型参数进行惩罚，从而限制模型的复杂度。常见的正则化方法包括L1正则化、L2正则化等。</p>
</li>
<li><p>采用Dropout方法。</p>
<p>Dropout是一种常用的防止过拟合的方法。它通过在训练过程中随机地将一些神经元的输出置为0，从而强制模型学习到多种特征表示。这样可以使得模型更加鲁棒，防止过拟合。</p>
</li>
<li><p>交又验证。</p>
<p>交又验证是一种常用的评估模型性能的方法。它将数据集分为若干份每次将其中一份作为验证集，其余部分作为训练集。这样可以多次训练模型，并在验证集上进行测试，从而得到一个更加准确的模型性能评估结果。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]:<a href="https://wenku.baidu.com/view/b718aa443269a45177232f60ddccda38376be1e6.html">https://wenku.baidu.com/view/b718aa443269a45177232f60ddccda38376be1e6.html</a>	“参考链接1”<br>[2]:<a href="https://blog.csdn.net/m0_69082030/article/details/128175288">https://blog.csdn.net/m0_69082030/article/details/128175288</a>	“参考链接2”</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
